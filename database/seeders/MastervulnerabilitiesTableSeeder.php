<?php

namespace Database\Seeders;

use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\DB;

class MastervulnerabilitiesTableSeeder extends Seeder
{
    /**
     * Run the database seeds.
     */
    public function run(): void
    {
        $data = [
            [
                'name' => 'CWE-5: J2EE Misconfiguration: Data Transmission Without Encryption',
                'description' => 'Information sent over a network can be compromised while in transit. An attacker may be able toread or modify the contents if the data are sent in plaintext or are weakly encrypted.',
                'mitigasi' => '<b> Phase: System Configuration</b>
                <p> The product configuration should ensure that SSL or an encryption mechanism of equivalent
                strength and vetted reputation is used for all access-controlled pages.</p>',
                'reference' => '[REF-6]Katrina Tsipenyuk, Brian Chess and Gary McGraw. "Seven Pernicious Kingdoms: A
                Taxonomy of Software Security Errors". NIST Workshop on Software Security Assurance Tools
                Techniques and Metrics. 2005 November 7. NIST. < https://samate.nist.gov/SSATTM_Content/
                papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security
                %20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf >.',
            ],
            [
                'name' => 'CWE-6: J2EE Misconfiguration: Insufficient Session-ID Length',
                'description' => 'The J2EE application is configured to use an insufficient session ID length.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Session identifiers should be at least 128 bits long to prevent brute-force session guessing. A shorter session identifier leaves the application open to brute-force session guessing attacks.</p>
                <b>Phase: Implementation</b>
                <p>A lower bound on the number of valid session identifiers that are available to be guessed is the
                number of users that are active on a site at any given moment. However, any users that abandon
                their sessions without logging out will increase this number. (This is one of many good reasons to
                have a short inactive session timeout.) With a 64 bit session identifier, assume 32 bits of entropy.
                For a large web site, assume that the attacker can try 1,000 guesses per second and that there
                are 10,000 valid session identifiers at any given moment. Given these assumptions, the expected
                time for an attacker to successfully guess a valid session identifier is less than 4 minutes. Now
                assume a 128 bit session identifier that provides 64 bits of entropy. With a very large web site, an
                attacker might try 10,000 guesses per second with 100,000 valid session identifiers available to
                be guessed. Given these assumptions, the expected time for an attacker to successfully guess a
                valid session identifier is greater than 292 years.
                </p>',
                'reference' => '<p>[REF-6]Katrina Tsipenyuk, Brian Chess and Gary McGraw. "Seven Pernicious Kingdoms: A
                Taxonomy of Software Security Errors". NIST Workshop on Software Security Assurance Tools
                Techniques and Metrics. 2005 November 7. NIST. < https://samate.nist.gov/SSATTM_Content/
                papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security
                %20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf >.</p>
                <p> [REF-482]Zvi Gutterman. "Hold Your Sessions: An Attack on Java Session-id Generation". 2005
                February 3. < https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/gm05.pdf
                >.2023-04-07.</p>',
            ],
            [
                'name' => 'CWE-7: J2EE Misconfiguration: Missing Custom Error Page',
                'description' => 'The default error page of a web application should not display sensitive information about the product.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Handle exceptions appropriately in source code</p> <br>
                <b>Phase: Implementation</b> <br>
                <b>Phase: System Configuration></b>
                <p>Always define appropriate error pages. The application configuration should specify a default
                error page in order to guarantee that the application will never leak error messages to an
                attacker. Handling standard HTTP error codes is useful and user-friendly in addition to being a
                good security practice, and a good configuration will also define a last-chance error handler that
                catches any exception that could possibly be thrown by the application.</p>
                <b>Phase: Implementation</b>
                <p>Do not attempt to process an error or attempt to mask it.
                </p>
                <b>Phase: Implementation</b>
                <p>Verify return values are correct and do not supply sensitive information about the system.</p>',
                'reference' => '<p>[REF-6]Katrina Tsipenyuk, Brian Chess and Gary McGraw. "Seven Pernicious Kingdoms: A
                Taxonomy of Software Security Errors". NIST Workshop on Software Security Assurance Tools
                Techniques and Metrics. 2005 November 7. NIST. < https://samate.nist.gov/SSATTM_Content/
                papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security
                %20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf >.</p>
                <p>[REF-65]M. Howard, D. LeBlanc and J. Viega. "19 Deadly Sins of Software Security". 2005 July 6. McGraw-Hill/Osborne.</p>',
            ],
            [
                'name' =>'CWE-8: J2EE Misconfiguration: Entity Bean Declared Remote',
                'description' => "When an application exposes a remote interface for an entity bean, it might also expose methods
                that get or set the bean's data. These methods could be leveraged to read sensitive information,
                or to change data in ways that violate the application's expectations, potentially leading to other
                vulnerabilities.",
                'mitigasi' =>'<b>Phase: Implementation</b>
                <p>Declare Java beans "local" when possible. When a bean must be remotely accessible, make
                sure that sensitive information is not exposed, and ensure that the application logic performs
                appropriate validation of any data that might be modified by an attacker.</p>',
                'refrence' => '<p>[REF-6]Katrina Tsipenyuk, Brian Chess and Gary McGraw. "Seven Pernicious Kingdoms: A
                Taxonomy of Software Security Errors". NIST Workshop on Software Security Assurance Tools
                Techniques and Metrics. 2005 November 7. NIST. < https://samate.nist.gov/SSATTM_Content/
                papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security
                %20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf >.</p>',
            ],
            [
                'name' => 'CWE-9: J2EE Misconfiguration: Weak Access Permissions for EJB Methods',
                'description' => 'If elevated access rights are assigned to EJB methods, then an attacker can take advantage of the
                permissions to exploit the product.',
                'mitigasi' => '<b>Phase: Architecture and Design</b> <br>
                <b>Phase: System Configuration</b>
                <p>Follow the principle of least privilege when assigning access rights to EJB methods. Permission
                to invoke EJB methods should not be granted to the ANYONE role.
                </p>',
                'refrence' => '<p>[REF-6]Katrina Tsipenyuk, Brian Chess and Gary McGraw. "Seven Pernicious Kingdoms: A
                Taxonomy of Software Security Errors". NIST Workshop on Software Security Assurance Tools
                Techniques and Metrics. 2005 November 7. NIST. < https://samate.nist.gov/SSATTM_Content/
                papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security
                %20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf >.</p>',
            ],
            [
                'name' => 'CWE-11: ASP.NET Misconfiguration: Creating Debug Binary',
                'description' => 'Debugging messages help attackers learn about the system and plan a form of attack.',
                'mitigasi' => '<b>Phase: System Configuration</b>
                <p>Avoid releasing debug binaries into the production environment. Change the debug mode to
                false when the application is deployed into production.</p>',
                'refrence' => '<p>[REF-6]Katrina Tsipenyuk, Brian Chess and Gary McGraw. "Seven Pernicious Kingdoms: A
                Taxonomy of Software Security Errors". NIST Workshop on Software Security Assurance Tools
                Techniques and Metrics. 2005 November 7. NIST. < https://samate.nist.gov/SSATTM_Content/
                papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security
                %20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf >.</p>',
            ],
            [
                'name' => 'CWE-12: ASP.NET Misconfiguration: Missing Custom Error Page',
                'description' => "An ASP .NET application must enable custom error pages in order to prevent attackers from mining
                information from the framework's built-in responses.",
                'mitigasi' => '<b>Phase: System Configuration</b>
                <p>Handle exceptions appropriately in source code. ASP .NET applications should be configured to
                use custom error pages instead of the framework default page.
                </p>
                <b>Phase: Architecture and Design</b>
                <p>Do not attempt to process an error or attempt to mask it</p>
                <b>Phase: Implementation</b>
                <p>Verify return values are correct and do not supply sensitive information about the system.</p>',
                'refrence' => '<p>[REF-6]Katrina Tsipenyuk, Brian Chess and Gary McGraw. "Seven Pernicious Kingdoms: A
                Taxonomy of Software Security Errors". NIST Workshop on Software Security Assurance Tools
                Techniques and Metrics. 2005 November 7. NIST. < https://samate.nist.gov/SSATTM_Content/
                papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security
                %20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf >.</p>
                <p> [REF-65]M. Howard, D. LeBlanc and J. Viega. "19 Deadly Sins of Software Security". 2005 July 6. McGraw-Hill/Osborne.</p>
                <p>  [REF-66]OWASP, Fortify Software. "ASP.NET Misconfiguration: Missing Custom Error Handling". < http://www.owasp.org/index.php/ASP.NET_Misconfiguration:_Missing_Custom_Error_Handling>.</p>',
            ],
            [
                'name' => 'CWE-13: ASP.NET Misconfiguration: Password in Configuration File',
                'description' =>'Storing a plaintext password in a configuration file allows anyone who can read the file access to
                the password-protected resource making them an easy target for attackers.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Credentials stored in configuration files should be encrypted, Use standard APIs and industry
                accepted algorithms to encrypt the credentials stored in configuration files.</p>',
                'refrence' =>'<p>[REF-6]Katrina Tsipenyuk, Brian Chess and Gary McGraw. "Seven Pernicious Kingdoms: A
                Taxonomy of Software Security Errors". NIST Workshop on Software Security Assurance Tools
                Techniques and Metrics. 2005 November 7. NIST. < https://samate.nist.gov/SSATTM_Content/
                papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security
                %20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf >.</p>
                <p>[REF-103]Microsoft Corporation. "How To: Encrypt Configuration Sections in ASP.NET 2.0 Using
                DPAPI". < https://learn.microsoft.com/en-us/previous-versions/msp-n-p/ff647398(v=pandp.10)?
                redirectedfrom=MSDN >.2023-04-07.</p>
                <p>[REF-104]Microsoft Corporation. "How To: Encrypt Configuration Sections in ASP.NET 2.0 Using
                RSA". < https://learn.microsoft.com/en-us/previous-versions/msp-n-p/ff650304(v=pandp.10)?
                redirectedfrom=MSDN >.2023-04-07.</p>
                <p>[REF-105]Microsoft Corporation. ".NET Framework Developer`s Guide - Securing Connection
                Strings". < http://msdn.microsoft.com/en-us/library/89211k9b(VS.80).aspx >.</p>',
            ],
            [
                'name' => 'CWE-14: Compiler Removal of Code to Clear Buffers',
                'description' => 'Sensitive memory is cleared according to the source code, but compiler optimizations leave the
                memory untouched when it is not read from again, aka "dead store removal." ',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Store the sensitive data in a "volatile" memory location if available.</p>
                <b>Phase: Build and Compilation</b>
                <p>If possible, configure your compiler so that it does not remove dead stores.</p>
                <b>Phase: Architecture and Design</b>
                <p>Where possible, encrypt sensitive data that are used by a software system</p>',
                'refrence' => '<p>[REF-6]Katrina Tsipenyuk, Brian Chess and Gary McGraw. "Seven Pernicious Kingdoms: A
                Taxonomy of Software Security Errors". NIST Workshop on Software Security Assurance Tools
                Techniques and Metrics. 2005 November 7. NIST. < https://samate.nist.gov/SSATTM_Content/
                papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security
                %20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf >.</p>
                <p>[REF-7]Michael Howard and David LeBlanc. "Writing Secure Code". 2nd Edition. 2002
                December 4. Microsoft Press. < https://www.microsoftpressstore.com/store/writing-securecode-9780735617223 >.
                </p>
                <p>[REF-124]Michael Howard. "When scrubbing secrets in memory doesn`t work". BugTraq. 2002
                November 5. < http://cert.uni-stuttgart.de/archive/bugtraq/2002/11/msg00046.html >.</p>
                <p>[REF-125]Michael Howard. "Some Bad News and Some Good News". 2002 October 1. Microsoft. <
                https://learn.microsoft.com/en-us/previous-versions/ms972826(v=msdn.10) >.2023-04-07.</p>
                <p>[REF-126]Joseph Wagner. "GNU GCC: Optimizer Removes Code Necessary for Security".
                Bugtraq. 2002 November 6. < https://seclists.org/bugtraq/2002/Nov/266 >.2023-04-07.</p>',
            ],
            [
                'name' => 'CWE-15: External Control of System or Configuration Setting',
                'description' => 'One or more system settings or configuration elements can be externally controlled by a user.',
                'mitigasi' => '<b>Phase: Architecture and Design</b>
                <p>Strategy = Separation of Privilege</p>
                <p>Compartmentalize the system to have "safe" areas where trust boundaries can be
                unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always
                be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate
                compartmentalization is built into the system design, and the compartmentalization allows for and
                reinforces privilege separation functionality. Architects and designers should rely on the principle
                of least privilege to decide the appropriate time to use privileges and the time to drop privileges.
                </p>
                <b>Phase: Implementation</b>
                <br>
                <b>Phase: Architecture and Design</b>
                <p>Because setting manipulation covers a diverse set of functions, any attempt at illustrating it
                will inevitably be incomplete. Rather than searching for a tight-knit relationship between the
                functions addressed in the setting manipulation category, take a step back and consider the sorts
                of system values that an attacker should not be allowed to control.
                </p>
                <b>Phase: Implementation
                </b>
                <br>
                <b>Phase: Architecture and Design</b>
                <p>In general, do not allow user-provided or otherwise untrusted data to control sensitive values.
                The leverage that an attacker gains by controlling these values is not always immediately
                obvious, but do not underestimate the creativity of the attacker.
                </p>',
                'refrerence' => '<p>[REF-6]Katrina Tsipenyuk, Brian Chess and Gary McGraw. "Seven Pernicious Kingdoms: A
                Taxonomy of Software Security Errors". NIST Workshop on Software Security Assurance Tools
                Techniques and Metrics. 2005 November 7. NIST. < https://samate.nist.gov/SSATTM_Content/
                papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security
                %20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf >.</p>',
            ],
            [
                'name' => 'CWE-20: Improper Input Validation',
                'description' => ' The product receives input or data, but it does not validate or incorrectly validates that the input has
                the properties that are required to process the data safely and correctly.',
                'mitigasi' => '<b>Phase: Architecture and Design</b>
                <p>Strategy = Attack Surface Reduction</p>
                <p>Consider using language-theoretic security (LangSec) techniques that characterize inputs using
                a formal language and build "recognizers" for that language. This effectively requires parsing
                to be a distinct layer that effectively enforces a boundary between raw input and internal data
                representations, instead of allowing parser code to be scattered throughout the program, where
                it could be subject to errors or inconsistencies that create weaknesses. [REF-1109] [REF-1110]
                [REF-1111]</p>
                <b>Phase: Architecture and Design</b>
                <p>Strategy = Libraries or Frameworks</p>
                <p>Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that
                using a framework does not automatically address all input validation problems; be mindful of
                weaknesses that could arise from misusing the framework itself (CWE-1173).
                </p>
                <b>Phase: Architecture and Design</b>
                </br>
                <b>Phase: Implementation</b>
                <p>Strategy = Attack Surface Reduction</p>
                <p>Understand all the potential areas where untrusted inputs can enter your software: parameters
                or arguments, cookies, anything read from the network, environment variables, reverse DNS
                lookups, query results, request headers, URL components, e-mail, files, filenames, databases,
                and any external systems that provide data to the application. Remember that such inputs may
                be obtained indirectly through API calls.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input
                is only expected to contain colors such as "red" or "blue." Do not rely exclusively on looking for
                malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if
                the code`s environment changes. This can give attackers enough room to bypass the intended
                validation. However, denylists can be useful for detecting potential attacks or determining which
                inputs are so malformed that they should be rejected outright.</p>
                <p>Effectiveness = High</p>
                <b>Phase: Architecture and Design</b>
                <p>For any security checks that are performed on the client side, ensure that these checks are
                duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side
                checks by modifying values after the checks have been performed, or by changing the client
                to remove the client-side checks entirely. Then, these modified values would be submitted to
                the server. Even though client-side checks provide minimal benefits with respect to serverside security, they are still useful. First, they can support intrusion detection. If the server
                receives input that should have been rejected by the client, then it may be an indication of an
                attack. Second, client-side error-checking can provide helpful feedback to the user about the
                expectations for valid input. Third, there may be a reduction in server-side processing time for
                accidental input errors, although this is typically a small savings.
                </p>
                <b>Phase: Implementation</b>
                <p>When your application combines data from multiple sources, perform the validation after the
                sources have been combined. The individual data elements may pass the validation step but
                violate the intended restrictions after they have been combined.
                </p>
                <b>Phase: Implementation</b>
                <p>Be especially careful to validate all input when invoking code that crosses language boundaries,
                such as from an interpreted language to native code. This could create an unexpected interaction
                between the language boundaries. Ensure that you are not violating any of the expectations
                of the language with which you are interfacing. For example, even though Java may not be
                susceptible to buffer overflows, providing a large argument in a call to native code might trigger
                an overflow</p>
                <b>Phase: Implementation</b>
                <p>Directly convert your input type into the expected data type, such as using a conversion function
                that translates a string into a number. After converting to the expected data type, ensure that the
                input`s values fall within the expected range of allowable values and that multi-field consistencies
                are maintained.
                </p>
                <b>Phase: Implementation</b>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180, CWE-181). Make sure that your application does not
                inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass
                allowlist schemes by introducing dangerous inputs after they have been checked. Use
                libraries such as the OWASP ESAPI Canonicalization control. Consider performing repeated
                canonicalization until your input does not change any more. This will avoid double-decoding and
                similar scenarios, but it might inadvertently modify inputs that are allowed to contain properlyencoded dangerous content.</p>
                <b>Phase: Implementation</b>
                <p>When exchanging data between components, ensure that both components are using the same
                character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set
                the encoding you are using whenever the protocol allows you to do so.</p>',
                'reference' => '<p>[REF-6]Katrina Tsipenyuk, Brian Chess and Gary McGraw. "Seven Pernicious Kingdoms: A
                Taxonomy of Software Security Errors". NIST Workshop on Software Security Assurance Tools
                Techniques and Metrics. 2005 November 7. NIST. < https://samate.nist.gov/SSATTM_Content/
                papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security
                %20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf >.</p>
                <p>[REF-166]Jim Manico. "Input Validation with ESAPI - Very Important". 2008 August 5. < https://
                manicode.blogspot.com/2008/08/input-validation-with-esapi.html >.2023-04-07.</p>
                <p>[REF-45]OWASP. "OWASP Enterprise Security API (ESAPI) Project". < http://www.owasp.org/
                index.php/ESAPI >.</p>
                <p>[REF-168]Joel Scambray, Mike Shema and Caleb Sima. "Hacking Exposed Web Applications,
                Second Edition". 2006 June 5. McGraw-Hill.</p>
                <p>[REF-48]Jeremiah Grossman. "Input validation or output filtering, which is better?". 2007 January 0.
                < https://blog.jeremiahgrossman.com/2007/01/input-validation-or-output-filtering.html >.2023-04-07.</p>
                <p>[REF-170]Kevin Beaver. "The importance of input validation". 2006 September 6. < http://
                searchsoftwarequality.techtarget.com/tip/0,289483,sid92_gci1214373,00.html >.</p>
                <p>[REF-7]Michael Howard and David LeBlanc. "Writing Secure Code". 2nd Edition. 2002
                December 4. Microsoft Press. < https://www.microsoftpressstore.com/store/writing-securecode-9780735617223 >.</p>
                <p>[REF-1109]"LANGSEC: Language-theoretic Security". < http://langsec.org/ >.</p>
                <p>[REF-1110]"LangSec: Recognition, Validation, and Compositional Correctness for Real World
                Security". < http://langsec.org/bof-handout.pdf >.
                </p>
                <p>[REF-1111]Sergey Bratus, Lars Hermerschmidt, Sven M. Hallberg, Michael E. Locasto, Falcon D.
                Momot, Meredith L. Patterson and Anna Shubina. "Curing the Vulnerable Parser: Design Patterns
                for Secure Input Handling". USENIX ;login:. 2017. < https://www.usenix.org/system/files/login/
                articles/login_spring17_08_bratus.pdf >.</p>
                <p>[REF-1287]MITRE. "Supplemental Details - 2022 CWE Top 25". 2022 June 8. < https://
                cwe.mitre.org/top25/archive/2022/2022_cwe_top25_supplemental.html#problematicMappingDetails
                >.</p>',
            ],
            [
                'name' => "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path
                Traversal')",
                'description' => 'The product uses external input to construct a pathname that is intended to identify a file or
                directory that is located underneath a restricted parent directory, but the product does not properly
                neutralize special elements within the pathname that can cause the pathname to resolve to a
                location that is outside of the restricted directory.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may
                be syntactically valid because it only contains alphanumeric characters, but it is not valid if
                the input is only expected to contain colors such as "red" or "blue." Do not rely exclusively on
                looking for malicious or malformed inputs. This is likely to miss at least one undesirable input,
                especially if the code`s environment changes. This can give attackers enough room to bypass
                the intended validation. However, denylists can be useful for detecting potential attacks or
                determining which inputs are so malformed that they should be rejected outright. When validating
                filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a
                single "." character in the filename to avoid weaknesses such as CWE-23, and exclude directory
                separators such as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help
                to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially
                dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For
                example, filtering "/" is insufficient protection if the filesystem also supports the use of "\" as a
                directory separator. Another possible error could occur when the filtering is applied in a way that
                still produces dangerous data (CWE-182). For example, if "../" sequences are removed from the
                ".../...//" string in a sequential fashion, two instances of "../" would be removed from the original
                string, but the remaining characters would still form the "../" string.</p>
                <b>Phase: Architecture and Design</b>
                <p>For any security checks that are performed on the client side, ensure that these checks are
                duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side
                checks by modifying values after the checks have been performed, or by changing the client to
                remove the client-side checks entirely. Then, these modified values would be submitted to the
                server.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked. Use a built-in path canonicalization
                function (such as realpath() in C) that produces the canonical version of the pathname, which
                effectively removes ".." sequences and symbolic links (CWE-23, CWE-59). This includes:
                realpath() in C getCanonicalPath() in Java GetFullPath() in ASP.NET realpath() or abs_path() in
                Perl realpath() in PHP</p>
                <b>Phase: Architecture and Design</b>
                <p>Strategy = Libraries or Frameworks</p>
                <p>Use a vetted library or framework that does not allow this weakness to occur or provides
                constructs that make this weakness easier to avoid.</p>
                <b>Phase: Operation</b>
                <p>Strategy = Firewall</p>
                <p>Use an application firewall that can detect attacks against this weakness. It can be beneficial
                in cases in which the code cannot be fixed (because it is controlled by a third party), as an
                emergency prevention measure while more comprehensive software assurance measures are
                applied, or to provide defense in depth.</p>
                <p>Effectiveness = Moderate</p>
                <p>An application firewall might not cover all possible input vectors. In addition, attack techniques
                might be available to bypass the protection mechanism, such as using malformed inputs that can
                still be processed by the component that receives those inputs. Depending on functionality, an
                application firewall might inadvertently reject or modify legitimate requests. Finally, some manual
                effort may be required for customization.
                </p>
                <b>Phase: Architecture and Design</b>
                </br>
                <b>Phase: Operation</b>
                <p>Strategy = Environment Hardening</p>
                <p>Run your code using the lowest privileges that are required to accomplish the necessary tasks
                [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a
                single task. That way, a successful attack will not immediately give the attacker access to the
                rest of the software or its environment. For example, database applications rarely need to run as
                the database administrator, especially in day-to-day operations.</p>
                <b>Phase: Architecture and Design</b>
                <p>Strategy = Enforcement by Conversion</p>
                <p>When the set of acceptable objects, such as filenames or URLs, is limited or known, create a
                mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs,
                and reject all other inputs. For example, ID 1 could map to "inbox.txt" and ID 2 could map to
                "profile.txt". Features such as the ESAPI AccessReferenceMap [REF-185] provide this capability.</p>
                <b>Phase: Architecture and Design</b>
                </br>
                <b>Phase: Operation</b>
                <p>Strategy = Sandbox or Jail</p>
                <p>Run the code in a "jail" or similar sandbox environment that enforces strict boundaries between
                the process and the operating system. This may effectively restrict which files can be accessed
                in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide
                some protection. For example, java.io.FilePermission in the Java SecurityManager allows the
                software to specify restrictions on file operations. This may not be a feasible solution, and it
                only limits the impact to the operating system; the rest of the application may still be subject to
                compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.</p>
                <p>Effectiveness = Limited</p>
                <p>The effectiveness of this mitigation depends on the prevention capabilities of the specific
                sandbox or jail being used and might only help to reduce the scope of an attack, such as
                restricting the attacker to certain system calls or limiting the portion of the file system that can be
                accessed.</p>
                <b>Phase: Architecture and Design</b>
                </br>
                <b>Phase: Operation</b>
                <p>Strategy = Attack Surface Reduction</p>
                <p>Store library, include, and utility files outside of the web document root, if possible. Otherwise,
                store them in a separate directory and use the web server`s access control capabilities to prevent
                attackers from directly requesting them. One common practice is to define a fixed constant in
                each calling program, then check for the existence of the constant in the library/include file; if the
                constant does not exist, then the file was directly requested, and it can exit immediately. This
                significantly reduces the chance of an attacker being able to bypass any protection mechanisms
                that are in the base program but not in the include files. It will also reduce the attack surface.</p>
                <b>Phase: Implementation</b>
                <p>Ensure that error messages only contain minimal details that are useful to the intended audience
                and no one else. The messages need to strike the balance between being too cryptic (which
                can confuse users) or being too detailed (which may reveal more than intended). The messages
                should not reveal the methods that were used to determine the error. Attackers can use detailed
                information to refine or optimize their original attack, thereby increasing their chances of success.
                If errors must be captured in some detail, record them in log messages, but consider what
                could occur if the log messages can be viewed by attackers. Highly sensitive information such
                as passwords should never be saved to log files. Avoid inconsistent messaging that might
                accidentally tip off an attacker about internal state, such as whether a user account exists or
                not. In the context of path traversal, error messages which disclose path information can help
                attackers craft the appropriate attack strings to move through the file system hierarchy.</p>
                <b>Phase: Operation</b>
                </br>
                <b>Phase: Implementation</b>
                <p>Strategy = Environment Hardening</p>
                <p>When using PHP, configure the application so that it does not use register_globals. During
                implementation, develop the application so that it does not rely on this feature, but be wary of
                implementing a register_globals emulation that is subject to weaknesses such as CWE-95,
                CWE-621, and similar issues.</p>',
                'refrence' => '<p>[REF-7]Michael Howard and David LeBlanc. "Writing Secure Code". 2nd Edition. 2002
                December 4. Microsoft Press. < https://www.microsoftpressstore.com/store/writing-securecode-9780735617223 >.</p>
                <p>[REF-45]OWASP. "OWASP Enterprise Security API (ESAPI) Project". < http://www.owasp.org/index.php/ESAPI >.</p>
                <p>[REF-185]OWASP. "Testing for Path Traversal (OWASP-AZ-001)". < http://www.owasp.org/index.php/Testing_for_Path_Traversal_(OWASP-AZ-001) >.</p>
                <p>[REF-186]Johannes Ullrich. "Top 25 Series - Rank 7 - Path Traversal". 2010 March 9. SANS
                Software Security Institute. < https://www.sans.org/blog/top-25-series-rank-7-path-traversal/>.2023-04-07.</p>
                <p>[REF-76]Sean Barnum and Michael Gegick. "Least Privilege". 2005 September 4. < https://
                web.archive.org/web/20211209014121/https://www.cisa.gov/uscert/bsi/articles/knowledge/
                principles/least-privilege >.2023-04-07.</p>
                <p>[REF-62]Mark Dowd, John McDonald and Justin Schuh. "The Art of Software Security
                Assessment". 1st Edition. 2006. Addison Wesley.</p>
                <p>[REF-962]Object Management Group (OMG). "Automated Source Code Security Measure
                (ASCSM)". 2016 January. < http://www.omg.org/spec/ASCSM/1.0/ >.</p>',
            ],
            [
                'name' => 'CWE-23: Relative Path Traversal',
                'description' => 'The product uses external input to construct a pathname that should be within a restricted
                directory, but it does not properly neutralize sequences such as ".." that can resolve to a location
                that is outside of that directory.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may
                be syntactically valid because it only contains alphanumeric characters, but it is not valid if
                the input is only expected to contain colors such as "red" or "blue." Do not rely exclusively on
                looking for malicious or malformed inputs. This is likely to miss at least one undesirable input,
                especially if the code`s environment changes. This can give attackers enough room to bypass
                the intended validation. However, denylists can be useful for detecting potential attacks or
                determining which inputs are so malformed that they should be rejected outright. When validating
                filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a
                single "." character in the filename to avoid weaknesses such as CWE-23, and exclude directory
                separators such as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help
                to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially
                dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For
                example, filtering "/" is insufficient protection if the filesystem also supports the use of "\" as a
                directory separator. Another possible error could occur when the filtering is applied in a way that
                still produces dangerous data (CWE-182). For example, if "../" sequences are removed from the
                ".../...//" string in a sequential fashion, two instances of "../" would be removed from the original
                string, but the remaining characters would still form the "../" string.
                </p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked. Use a built-in path canonicalization
                function (such as realpath() in C) that produces the canonical version of the pathname, which
                effectively removes ".." sequences and symbolic links (CWE-23, CWE-59). This includes:
                realpath() in C getCanonicalPath() in Java GetFullPath() in ASP.NET realpath() or abs_path() in
                Perl realpath() in PHP</p>',
                'reference' => '<p>[REF-192]OWASP. "OWASP Attack listing". < http://www.owasp.org/index.php/
                Relative_Path_Traversal >.</p>
                <p>[REF-62]Mark Dowd, John McDonald and Justin Schuh. "The Art of Software Security
                Assessment". 1st Edition. 2006. Addison Wesley.
                </p>
                <p>[REF-1282]Snyk. "Zip Slip Vulnerability". 2018 June 5. < https://security.snyk.io/research/zip-slipvulnerability >.
                </p>',
            ],
            [
                'name' => "CWE-24: Path Traversal: '../filedir'",
                'description' => 'The product uses external input to construct a pathname that should be within a restricted
                directory, but it does not properly neutralize "../" sequences that can resolve to a location that is
                outside of that directory.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may
                be syntactically valid because it only contains alphanumeric characters, but it is not valid if
                the input is only expected to contain colors such as "red" or "blue." Do not rely exclusively on
                looking for malicious or malformed inputs. This is likely to miss at least one undesirable input,
                especially if the code`s environment changes. This can give attackers enough room to bypass
                the intended validation. However, denylists can be useful for detecting potential attacks or
                determining which inputs are so malformed that they should be rejected outright. When validating
                filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a
                single "." character in the filename to avoid weaknesses such as CWE-23, and exclude directory
                separators such as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help
                to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially
                dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For
                example, filtering "/" is insufficient protection if the filesystem also supports the use of "\" as a
                directory separator. Another possible error could occur when the filtering is applied in a way that
                still produces dangerous data (CWE-182). For example, if "../" sequences are removed from the
                ".../...//" string in a sequential fashion, two instances of "../" would be removed from the original
                string, but the remaining characters would still form the "../" string.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.
                </p>',
                'reference' => '-',
            ],
            [
                'name' => "CWE-25: Path Traversal: '/../filedir' ",
                'description' => 'The product uses external input to construct a pathname that should be within a restricted
                directory, but it does not properly neutralize "/../" sequences that can resolve to a location that is
                outside of that directory.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may
                be syntactically valid because it only contains alphanumeric characters, but it is not valid if
                the input is only expected to contain colors such as "red" or "blue." Do not rely exclusively on
                looking for malicious or malformed inputs. This is likely to miss at least one undesirable input,
                especially if the code`s environment changes. This can give attackers enough room to bypass
                the intended validation. However, denylists can be useful for detecting potential attacks or
                determining which inputs are so malformed that they should be rejected outright. When validating
                filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a
                single "." character in the filename to avoid weaknesses such as CWE-23, and exclude directory
                separators such as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help
                to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially
                dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For
                example, filtering "/" is insufficient protection if the filesystem also supports the use of "\" as a
                directory separator. Another possible error could occur when the filtering is applied in a way that
                still produces dangerous data (CWE-182). For example, if "../" sequences are removed from the
                ".../...//" string in a sequential fashion, two instances of "../" would be removed from the original
                string, but the remaining characters would still form the "../" string.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.</p>',
                'reference' => '-',
            ],
            [
                'name' => "CWE-26: Path Traversal: '/dir/../filename'",
                'description' => 'The product uses external input to construct a pathname that should be within a restricted
                directory, but it does not properly neutralize "/dir/../filename" sequences that can resolve to a
                location that is outside of that directory.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may
                be syntactically valid because it only contains alphanumeric characters, but it is not valid if
                the input is only expected to contain colors such as "red" or "blue." Do not rely exclusively on
                looking for malicious or malformed inputs. This is likely to miss at least one undesirable input,
                especially if the code`s environment changes. This can give attackers enough room to bypass
                the intended validation. However, denylists can be useful for detecting potential attacks or
                determining which inputs are so malformed that they should be rejected outright. When validating
                filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a
                single "." character in the filename to avoid weaknesses such as CWE-23, and exclude directory
                separators such as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help
                to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially
                dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For
                example, filtering "/" is insufficient protection if the filesystem also supports the use of "\" as a
                directory separator. Another possible error could occur when the filtering is applied in a way that
                still produces dangerous data (CWE-182). For example, if "../" sequences are removed from the
                ".../...//" string in a sequential fashion, two instances of "../" would be removed from the original
                string, but the remaining characters would still form the "../" string.
                </p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.
                </p>',
                'reference' => '-',
            ],
            [
                'name' => "CWE-27: Path Traversal: 'dir/../../filename'",
                'description' => 'The product uses external input to construct a pathname that should be within a restricted
                directory, but it does not properly neutralize multiple internal "../" sequences that can resolve to a
                location that is outside of that directory.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may
                be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as "red" or "blue." Do not rely exclusively on
                looking for malicious or malformed inputs. This is likely to miss at least one undesirable input,
                especially if the code`s environment changes. This can give attackers enough room to bypass
                the intended validation. However, denylists can be useful for detecting potential attacks or
                determining which inputs are so malformed that they should be rejected outright. When validating
                filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a
                single "." character in the filename to avoid weaknesses such as CWE-23, and exclude directory
                separators such as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help
                to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially
                dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For
                example, filtering "/" is insufficient protection if the filesystem also supports the use of "\" as a
                directory separator. Another possible error could occur when the filtering is applied in a way that
                still produces dangerous data (CWE-182). For example, if "../" sequences are removed from the
                ".../...//" string in a sequential fashion, two instances of "../" would be removed from the original
                string, but the remaining characters would still form the "../" string.
                </p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.</p>',
                'reference' => '-',
            ],
            [
                'name' => "CWE-28: Path Traversal: '..\filedir'",
                'description' => 'The product uses external input to construct a pathname that should be within a restricted
                directory, but it does not properly neutralize "..\" sequences that can resolve to a location that is
                outside of that directory.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may
                be syntactically valid because it only contains alphanumeric characters, but it is not valid if
                the input is only expected to contain colors such as "red" or "blue." Do not rely exclusively on
                looking for malicious or malformed inputs. This is likely to miss at least one undesirable input,
                especially if the code`s environment changes. This can give attackers enough room to bypass
                the intended validation. However, denylists can be useful for detecting potential attacks or
                determining which inputs are so malformed that they should be rejected outright. When validating
                filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a
                single "." character in the filename to avoid weaknesses such as CWE-23, and exclude directory
                separators such as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help
                to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially
                dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For
                example, filtering "/" is insufficient protection if the filesystem also supports the use of "\" as a
                directory separator. Another possible error could occur when the filtering is applied in a way that
                still produces dangerous data (CWE-182). For example, if "../" sequences are removed from the
                ".../...//" string in a sequential fashion, two instances of "../" would be removed from the original
                string, but the remaining characters would still form the "../" string
                </p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.</p>',
                'refernce' => '-',
            ],
            [
                'name' => "CWE-29: Path Traversal: '\..\filename'",
                'description' => "The product uses external input to construct a pathname that should be within a restricted
                directory, but it does not properly neutralize '\..\filename' (leading backslash dot dot) sequences
                that can resolve to a location that is outside of that directory.",
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may
                be syntactically valid because it only contains alphanumeric characters, but it is not valid if
                the input is only expected to contain colors such as "red" or "blue." Do not rely exclusively on
                looking for malicious or malformed inputs. This is likely to miss at least one undesirable input,
                especially if the code`s environment changes. This can give attackers enough room to bypass
                the intended validation. However, denylists can be useful for detecting potential attacks or
                determining which inputs are so malformed that they should be rejected outright. When validating
                filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a
                single "." character in the filename to avoid weaknesses such as CWE-23, and exclude directory
                separators such as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help
                to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially
                dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For
                example, filtering "/" is insufficient protection if the filesystem also supports the use of "\" as a
                directory separator. Another possible error could occur when the filtering is applied in a way that
                still produces dangerous data (CWE-182). For example, if "../" sequences are removed from the
                ".../...//" string in a sequential fashion, two instances of "../" would be removed from the original
                string, but the remaining characters would still form the "../" string.
                </p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.</p>',
                'reference' => '-'
            ],
            [
                'name' => "CWE-30: Path Traversal: '\dir\..\filename'",
                'description' => "The product uses external input to construct a pathname that should be within a restricted
                directory, but it does not properly neutralize '\dir\..\filename' (leading backslash dot dot) sequences
                that can resolve to a location that is outside of that directory.",
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may
                be syntactically valid because it only contains alphanumeric characters, but it is not valid if
                the input is only expected to contain colors such as "red" or "blue." Do not rely exclusively on
                looking for malicious or malformed inputs. This is likely to miss at least one undesirable input,
                especially if the code`s environment changes. This can give attackers enough room to bypass
                the intended validation. However, denylists can be useful for detecting potential attacks or
                determining which inputs are so malformed that they should be rejected outright. When validating
                filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a
                single "." character in the filename to avoid weaknesses such as CWE-23, and exclude directory
                separators such as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help
                to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially
                dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For
                example, filtering "/" is insufficient protection if the filesystem also supports the use of "\" as a
                directory separator. Another possible error could occur when the filtering is applied in a way that
                still produces dangerous data (CWE-182). For example, if "../" sequences are removed from the
                ".../...//" string in a sequential fashion, two instances of "../" would be removed from the original
                string, but the remaining characters would still form the "../" string.
                </p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.</p>',
                'reference' => '-',
            ],
            [
                'name' => "CWE-31: Path Traversal: 'dir\..\..\filename'",
                'description' => "The product uses external input to construct a pathname that should be within a restricted
                directory, but it does not properly neutralize 'dir\..\..\filename' (multiple internal backslash dot dot)
                sequences that can resolve to a location that is outside of that directory.",
                "mitigasi" => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may
                be syntactically valid because it only contains alphanumeric characters, but it is not valid if
                the input is only expected to contain colors such as "red" or "blue." Do not rely exclusively on
                looking for malicious or malformed inputs. This is likely to miss at least one undesirable input,
                especially if the code`s environment changes. This can give attackers enough room to bypass
                the intended validation. However, denylists can be useful for detecting potential attacks or
                determining which inputs are so malformed that they should be rejected outright. When validating
                filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a
                single "." character in the filename to avoid weaknesses such as CWE-23, and exclude directory
                separators such as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help
                to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially
                dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For
                example, filtering "/" is insufficient protection if the filesystem also supports the use of "\" as a
                directory separator. Another possible error could occur when the filtering is applied in a way that
                still produces dangerous data (CWE-182). For example, if "../" sequences are removed from the
                ".../...//" string in a sequential fashion, two instances of "../" would be removed from the original
                string, but the remaining characters would still form the "../" string.
                </p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.</p>',
                'reference' => '<p>[REF-44]Michael Howard, David LeBlanc and John Viega. "24 Deadly Sins of Software Security".
                McGraw-Hill. 2010.</p>',
            ],
            [
                'name' => "CWE-32: Path Traversal: '...' (Triple Dot)",
                'description' => "The product uses external input to construct a pathname that should be within a restricted
                directory, but it does not properly neutralize '...' (triple dot) sequences that can resolve to a location
                that is outside of that directory.",
                'description' => "The product uses external input to construct a pathname that should be within a restricted
                directory, but it does not properly neutralize '...' (triple dot) sequences that can resolve to a location
                that is outside of that directory.",
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may
                be syntactically valid because it only contains alphanumeric characters, but it is not valid if
                the input is only expected to contain colors such as "red" or "blue." Do not rely exclusively on
                looking for malicious or malformed inputs. This is likely to miss at least one undesirable input,
                especially if the code`s environment changes. This can give attackers enough room to bypass
                the intended validation. However, denylists can be useful for detecting potential attacks or
                determining which inputs are so malformed that they should be rejected outright. When validating
                filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a
                single "." character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help
                to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially
                dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For
                example, filtering "/" is insufficient protection if the filesystem also supports the use of "\" as a
                directory separator. Another possible error could occur when the filtering is applied in a way that
                still produces dangerous data (CWE-182). For example, if "../" sequences are removed from the
                ".../...//" string in a sequential fashion, two instances of "../" would be removed from the original
                string, but the remaining characters would still form the "../" string.
                </p>
                <p>Effectiveness = High</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.</p>',
                'reference' => '-',
            ],
            [
                'name' => "CWE-33: Path Traversal: '....' (Multiple Dot)",
                'description' => "The product uses external input to construct a pathname that should be within a restricted
                directory, but it does not properly neutralize '....' (multiple dot) sequences that can resolve to a
                location that is outside of that directory.",
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if
                the input is only expected to contain colors such as "red" or "blue." Do not rely exclusively on
                looking for malicious or malformed inputs. This is likely to miss at least one undesirable input,
                especially if the code`s environment changes. This can give attackers enough room to bypass
                the intended validation. However, denylists can be useful for detecting potential attacks or
                determining which inputs are so malformed that they should be rejected outright. When validating
                filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a
                single "." character in the filename to avoid weaknesses such as CWE-23, and exclude directory
                separators such as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help
                to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially
                dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For
                example, filtering "/" is insufficient protection if the filesystem also supports the use of "\" as a
                directory separator. Another possible error could occur when the filtering is applied in a way that
                still produces dangerous data (CWE-182). For example, if "../" sequences are removed from the
                ".../...//" string in a sequential fashion, two instances of "../" would be removed from the original
                string, but the remaining characters would still form the "../" string.</p>
                <p>Effectiveness = High</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.</p>',
                'reference' => '-',
            ],
            [
                'name' => "CWE-34: Path Traversal: '....//'",
                'description' => "The product uses external input to construct a pathname that should be within a restricted
                directory, but it does not properly neutralize '....//' (doubled dot dot slash) sequences that can
                resolve to a location that is outside of that directory.",
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may
                be syntactically valid because it only contains alphanumeric characters, but it is not valid if
                the input is only expected to contain colors such as "red" or "blue." Do not rely exclusively on
                looking for malicious or malformed inputs. This is likely to miss at least one undesirable input,
                especially if the code`s environment changes. This can give attackers enough room to bypass
                the intended validation. However, denylists can be useful for detecting potential attacks or
                determining which inputs are so malformed that they should be rejected outright. When validating
                filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a
                single "." character in the filename to avoid weaknesses such as CWE-23, and exclude directory
                separators such as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help
                to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially
                dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For
                example, filtering "/" is insufficient protection if the filesystem also supports the use of "\" as a
                directory separator. Another possible error could occur when the filtering is applied in a way that
                still produces dangerous data (CWE-182). For example, if "../" sequences are removed from the
                ".../...//" string in a sequential fashion, two instances of "../" would be removed from the original
                string, but the remaining characters would still form the "../" string.</p>
                <p>Effectiveness = High</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.
                </p>',
                'reference' => '-',
            ],
            [
                'name' => "CWE-35: Path Traversal: '.../...//'",
                'description' => "The product uses external input to construct a pathname that should be within a restricted
                directory, but it does not properly neutralize '.../...//' (doubled triple dot slash) sequences that can
                resolve to a location that is outside of that directory.",
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may
                be syntactically valid because it only contains alphanumeric characters, but it is not valid if
                the input is only expected to contain colors such as "red" or "blue." Do not rely exclusively on
                looking for malicious or malformed inputs. This is likely to miss at least one undesirable input,
                especially if the code`s environment changes. This can give attackers enough room to bypass
                the intended validation. However, denylists can be useful for detecting potential attacks or
                determining which inputs are so malformed that they should be rejected outright. When validating
                filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a
                single "." character in the filename to avoid weaknesses such as CWE-23, and exclude directory
                separators such as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help
                to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially
                dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For
                example, filtering "/" is insufficient protection if the filesystem also supports the use of "\" as a
                directory separator. Another possible error could occur when the filtering is applied in a way that
                still produces dangerous data (CWE-182). For example, if "../" sequences are removed from the
                ".../...//" string in a sequential fashion, two instances of "../" would be removed from the original
                string, but the remaining characters would still form the "../" string.</p>
                <p>Effectiveness = High</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.</p>',
                'reference' => '-',
            ],
            [
                'name' => 'CWE-36: Absolute Path Traversal',
                'description' => 'The product uses external input to construct a pathname that should be within a restricted
                directory, but it does not properly neutralize absolute path sequences such as "/abs/path" that can
                resolve to a location that is outside of that directory.',
                'mitigasi' => '-',
                'reference' => '<p>[REF-62]Mark Dowd, John McDonald and Justin Schuh. "The Art of Software Security
                Assessment". 1st Edition. 2006. Addison Wesley.</p>',
            ],
            [
                'name' => "CWE-37: Path Traversal: '/absolute/pathname/here'",
                'description' => "The product accepts input in the form of a slash absolute path ('/absolute/pathname/here') without
                appropriate validation, which can allow an attacker to traverse the file system to unintended
                locations or access arbitrary files.",
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may
                be syntactically valid because it only contains alphanumeric characters, but it is not valid if
                the input is only expected to contain colors such as "red" or "blue." Do not rely exclusively on
                looking for malicious or malformed inputs. This is likely to miss at least one undesirable input,
                especially if the code`s environment changes. This can give attackers enough room to bypass
                the intended validation. However, denylists can be useful for detecting potential attacks or
                determining which inputs are so malformed that they should be rejected outright. When validating
                filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a
                single "." character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help
                to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially
                dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For
                example, filtering "/" is insufficient protection if the filesystem also supports the use of "\" as a
                directory separator. Another possible error could occur when the filtering is applied in a way that
                still produces dangerous data (CWE-182). For example, if "../" sequences are removed from the
                ".../...//" string in a sequential fashion, two instances of "../" would be removed from the original
                string, but the remaining characters would still form the "../" string.
                </p>
                <p>Effectiveness = High</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.</p>',
                'reference' => '-',
            ],
            [
                'name' => "CWE-38: Path Traversal: '\absolute\pathname\here'",
                'description' => "The product accepts input in the form of a backslash absolute path ('\absolute\pathname\here')
                without appropriate validation, which can allow an attacker to traverse the file system to unintended
                locations or access arbitrary files.",
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may
                be syntactically valid because it only contains alphanumeric characters, but it is not valid if
                the input is only expected to contain colors such as "red" or "blue." Do not rely exclusively on
                looking for malicious or malformed inputs. This is likely to miss at least one undesirable input,
                especially if the code`s environment changes. This can give attackers enough room to bypass
                the intended validation. However, denylists can be useful for detecting potential attacks or
                determining which inputs are so malformed that they should be rejected outright. When validating
                filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a
                single "." character in the filename to avoid weaknesses such as CWE-23, and exclude directory
                separators such as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help
                to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially
                dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For
                example, filtering "/" is insufficient protection if the filesystem also supports the use of "\" as a
                directory separator. Another possible error could occur when the filtering is applied in a way that
                still produces dangerous data (CWE-182). For example, if "../" sequences are removed from the
                ".../...//" string in a sequential fashion, two instances of "../" would be removed from the original
                string, but the remaining characters would still form the "../" string.</p>
                <p>Effectiveness = High</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.</p>',
                'reference' => '-'
            ],
            [
                'name' => "CWE-39: Path Traversal: 'C:dirname",
                'description' => "The product accepts input that contains a drive letter or Windows volume letter ('C:dirname') that
                potentially redirects access to an unintended location or arbitrary file.",
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may
                be syntactically valid because it only contains alphanumeric characters, but it is not valid if
                the input is only expected to contain colors such as "red" or "blue." Do not rely exclusively on
                looking for malicious or malformed inputs. This is likely to miss at least one undesirable input,
                especially if the code`s environment changes. This can give attackers enough room to bypass
                the intended validation. However, denylists can be useful for detecting potential attacks or
                determining which inputs are so malformed that they should be rejected outright. When validating
                filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a
                single "." character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help
                to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially
                dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For
                example, filtering "/" is insufficient protection if the filesystem also supports the use of "\" as a
                directory separator. Another possible error could occur when the filtering is applied in a way that
                still produces dangerous data (CWE-182). For example, if "../" sequences are removed from the
                ".../...//" string in a sequential fashion, two instances of "../" would be removed from the original
                string, but the remaining characters would still form the "../" string.</p>
                <p>Effectiveness = High</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.
                </p>',
                'reference' => '-',
            ],
            [
                'name' => "CWE-40: Path Traversal: '\\UNC\share\name\' (Windows UNC Share)",
                'description' => "The product accepts input that identifies a Windows UNC share ('\\UNC\share\name') that
                potentially redirects access to an unintended location or arbitrary file.",
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may
                be syntactically valid because it only contains alphanumeric characters, but it is not valid if
                the input is only expected to contain colors such as "red" or "blue." Do not rely exclusively on
                looking for malicious or malformed inputs. This is likely to miss at least one undesirable input,
                especially if the code`s environment changes. This can give attackers enough room to bypass
                the intended validation. However, denylists can be useful for detecting potential attacks or
                determining which inputs are so malformed that they should be rejected outright. When validating
                filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a
                single "." character in the filename to avoid weaknesses such as CWE-23, and exclude directory
                separators such as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help
                to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially
                dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering "/" is insufficient protection if the filesystem also supports the use of "\" as a
                directory separator. Another possible error could occur when the filtering is applied in a way that
                still produces dangerous data (CWE-182). For example, if "../" sequences are removed from the
                ".../...//" string in a sequential fashion, two instances of "../" would be removed from the original
                string, but the remaining characters would still form the "../" string.</p>
                <p>Effectiveness = High</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.</p>',
                'reference' => '[REF-62]Mark Dowd, John McDonald and Justin Schuh. "The Art of Software Security
                Assessment". 1st Edition. 2006. Addison Wesley.',
            ],
            [
                'name' => 'CWE-41: Improper Resolution of Path Equivalence',
                'description' => 'The product is vulnerable to file system contents disclosure through path equivalence. Path
                equivalence involves the use of special characters in file and directory names. The associated
                manipulations are intended to generate multiple names for the same object.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may be
                syntactically valid because it only contains alphanumeric characters, but it is not valid if the input
                is only expected to contain colors such as "red" or "blue." Do not rely exclusively on looking for
                malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if
                the code`s environment changes. This can give attackers enough room to bypass the intended
                validation. However, denylists can be useful for detecting potential attacks or determining which
                inputs are so malformed that they should be rejected outright.</p>
                <p>Strategy = Output Encoding</p>
                <p>Use and specify an output encoding that can be handled by the downstream component that
                is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an
                encoding is not specified, a downstream component may choose a different encoding, either
                by assuming a default encoding or automatically inferring which encoding is being used, which
                can be erroneous. When the encodings are inconsistent, the downstream component might
                treat some character or byte sequences as special, even if they are not special in the original
                encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks;
                they even might be able to bypass protection mechanisms that assume the original encoding is
                also being used by the downstream component.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.
                </p>',
                'reference' => '-',
            ],
            [
                'name' => "CWE-42: Path Equivalence: 'filename.' (Trailing Dot)",
                'description'=> "The product accepts path input in the form of trailing dot ('filedir.') without appropriate validation,
                which can lead to ambiguous path resolution and allow an attacker to traverse the file system to
                unintended locations or access arbitrary files.",
                'mitigasi'=> '-',
                'reference' => '-',
            ],
            [
                'name' => "CWE-43: Path Equivalence: 'filename....' (Multiple Trailing Dot)",
                'description' => "The product accepts path input in the form of multiple trailing dot ('filedir....') without appropriate
                validation, which can lead to ambiguous path resolution and allow an attacker to traverse the file
                system to unintended locations or access arbitrary files.",
                'mitigasi' => '-',
                'reference' => '-',
            ],
            [
                'name' => "CWE-44: Path Equivalence: 'file.name' (Internal Dot)",
                'description' => "The product accepts path input in the form of internal dot ('file.ordir') without appropriate validation,
                which can lead to ambiguous path resolution and allow an attacker to traverse the file system to
                unintended locations or access arbitrary files.",
                'mitigasi' => '-',
                'reference' => '-',
            ],
            [
                'name'=>"CWE-45: Path Equivalence: 'file...name' (Multiple Internal Dot)",
                'description'=> "The product accepts path input in the form of multiple internal dot ('file...dir') without appropriate
                validation, which can lead to ambiguous path resolution and allow an attacker to traverse the file
                system to unintended locations or access arbitrary files.",
                'mitigasi' => '-',
                'reference' => '-',
            ],
            [
                'name' => "CWE-46: Path Equivalence: 'filename ' (Trailing Space)",
                'description' => "The product accepts path input in the form of trailing space ('filedir ') without appropriate validation,
                which can lead to ambiguous path resolution and allow an attacker to traverse the file system to
                unintended locations or access arbitrary files.",
                'mitigasi' => '-',
                'reference' => '-',
            ],
            [
                'name' => "CWE-47: Path Equivalence: ' filename' (Leading Space)",
                'description' => "The product accepts path input in the form of leading space (' filedir') without appropriate validation,
                which can lead to ambiguous path resolution and allow an attacker to traverse the file system to
                unintended locations or access arbitrary files.",
                'mitigasi' => '-',
                'reference' => '-',
            ],
            [
                'name' => "CWE-48: Path Equivalence: 'file name' (Internal Whitespace)",
                'description' => "The product accepts path input in the form of internal space ('file(SPACE)name') without
                appropriate validation, which can lead to ambiguous path resolution and allow an attacker to
                traverse the file system to unintended locations or access arbitrary files.",
                'mitigasi' => '-',
                'reference' => '-',
            ],
            [
                'name' => "CWE-49: Path Equivalence: 'filename/' (Trailing Slash)",
                'description' => "The product accepts path input in the form of trailing slash ('filedir/') without appropriate validation,
                which can lead to ambiguous path resolution and allow an attacker to traverse the file system to
                unintended locations or access arbitrary files.",
                'mitigasi' => '-',
                'reference' => '-',
            ],
            [
                'name' => "CWE-50: Path Equivalence: '//multiple/leading/slash'",
                'description' => "The product accepts path input in the form of multiple leading slash ('//multiple/leading/slash')
                without appropriate validation, which can lead to ambiguous path resolution and allow an attacker
                to traverse the file system to unintended locations or access arbitrary files.",
                'mitigasi' => '-',
                'reference' => '-',
            ],
            [
                'name' => "CWE-51: Path Equivalence: '/multiple//internal/slash'",
                'description' => "The product accepts path input in the form of multiple internal slash ('/multiple//internal/slash/')
                without appropriate validation, which can lead to ambiguous path resolution and allow an attacker
                to traverse the file system to unintended locations or access arbitrary files.",
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.</p>',
                'reference' => '-',
            ],
            [
                'name' => "CWE-52: Path Equivalence: '/multiple/trailing/slash//'",
                'desxription' => "The product accepts path input in the form of multiple trailing slash ('/multiple/trailing/slash//')
                without appropriate validation, which can lead to ambiguous path resolution and allow an attacker
                to traverse the file system to unintended locations or access arbitrary files.",
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.
                </p>',
                'reference' => '-',
            ],
            [
                'name' => "CWE-53: Path Equivalence: '\multiple\\internal\backslash'",
                'description' => "The product accepts path input in the form of multiple internal backslash ('\multiple\trailing\\slash')
                without appropriate validation, which can lead to ambiguous path resolution and allow an attacker
                to traverse the file system to unintended locations or access arbitrary files.",
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.
                </p>',
                'reference' => '-',
            ],
            [
                'name' => "CWE-54: Path Equivalence: 'filedir\' (Trailing Backslash)",
                'description' => "The product accepts path input in the form of trailing backslash ('filedir\') without appropriate
                validation, which can lead to ambiguous path resolution and allow an attacker to traverse the file
                system to unintended locations or access arbitrary files.",
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.</p>',
                'reference' => '-',
            ],
            [
                'name' => "CWE-55: Path Equivalence: '/./' (Single Dot Directory)",
                'description' => "The product accepts path input in the form of single dot directory exploit ('/./') without appropriate
                validation, which can lead to ambiguous path resolution and allow an attacker to traverse the file
                system to unintended locations or access arbitrary files.",
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.</p>',
                'reference' => '-',
            ],
            [
                'name' => "CWE-56: Path Equivalence: 'filedir*' (Wildcard)",
                'description' => "The product accepts path input in the form of asterisk wildcard ('filedir*') without appropriate
                validation, which can lead to ambiguous path resolution and allow an attacker to traverse the file
                system to unintended locations or access arbitrary files.",
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.
                </p>',
                'reference' => '-',
            ],
            [
                'name' => "CWE-57: Path Equivalence: 'fakedir/../realdir/filename'",
                'description' => "The product contains protection mechanisms to restrict access to 'realdir/filename', but it constructs
                pathnames using external input in the form of 'fakedir/../realdir/filename' that are not handled by
                those mechanisms. This allows attackers to perform unauthorized actions against the targeted file.",
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180). Make sure that the application does not decode the same
                input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by
                introducing dangerous inputs after they have been checked.
                </p>',
                'reference' => '-',
            ],
            [
                'name' => 'CWE-58: Path Equivalence: Windows 8.3 Filename',
                'description' => 'The product contains a protection mechanism that restricts access to a long filename on a
                Windows operating system, but it does not properly restrict access to the equivalent short "8.3"
                filename.',
                'mitigasi' => '<b>Phase: System Configuration</b>
                <p>Disable Windows from supporting 8.3 filenames by editing the Windows registry. Preventing 8.3
                filenames will not remove previously generated 8.3 filenames.</p>',
                'reference' => '<p>[REF-7]Michael Howard and David LeBlanc. "Writing Secure Code". 2nd Edition. 2002
                December 4. Microsoft Press. < https://www.microsoftpressstore.com/store/writing-securecode-9780735617223 >.</p>
                <p>[REF-62]Mark Dowd, John McDonald and Justin Schuh. "The Art of Software Security
                Assessment". 1st Edition. 2006. Addison Wesley.</p>',
            ],
            [
                'name' => "CWE-59: Improper Link Resolution Before File Access ('Link Following')",
                'description' => 'The product attempts to access a file based on the filename, but it does not properly prevent that
                filename from identifying a link or shortcut that resolves to an unintended resource.',
                'mitigasi' => '<b>Phase: Architecture and Design</b>
                <p>Strategy = Separation of Privilege</p>
                <p>Follow the principle of least privilege when assigning access rights to entities in a software
                system. Denying access to a file can prevent an attacker from replacing that file with a link to a
                sensitive file. Ensure good compartmentalization in the system to provide protected areas that
                can be trusted.</p>',
                'reference' => '<p>[REF-62]Mark Dowd, John McDonald and Justin Schuh. "The Art of Software Security
                Assessment". 1st Edition. 2006. Addison Wesley.</p>
                <p>[REF-1282]Snyk. "Zip Slip Vulnerability". 2018 June 5. < https://security.snyk.io/research/zip-slipvulnerability >.</p>'
            ],
            [
               'name'=>'CWE-61: UNIX Symbolic Link (Symlink) Following',
               'description' => 'The product, when opening a file or directory, does not sufficiently account for when the file is a
               symbolic link that resolves to a target outside of the intended control sphere. This could allow an
               attacker to cause the product to operate on unauthorized files.',
               'mitigasi' => '<b>Phase: Implementation</b>
               <p>Symbolic link attacks often occur when a program creates a tmp directory that stores files/
               links. Access to the directory should be restricted to the program as to prevent attackers from
               manipulating the files.</p>
               <b>Phase: Architecture and Design</b>
               <p>Strategy = Separation of Privilege</p>
               <p>Follow the principle of least privilege when assigning access rights to entities in a software
               system. Denying access to a file can prevent an attacker from replacing that file with a link to a
               sensitive file. Ensure good compartmentalization in the system to provide protected areas that
               can be trusted.</p>',
               'reference' => '<p>[REF-493]Steve Christey. "Second-Order Symlink Vulnerabilities". Bugtraq. 2005 June 7. < https://
               seclists.org/bugtraq/2005/Jun/44 >.2023-04-07.</p>
               <p>[REF-494]Shaun Colley. "Crafting Symlinks for Fun and Profit". Infosec Writers Text Library. 2004
               April 2. < http://www.infosecwriters.com/texts.php?op=display&id=159 >.
               </p>
               <p>[REF-62]Mark Dowd, John McDonald and Justin Schuh. "The Art of Software Security
               Assessment". 1st Edition. 2006. Addison Wesley.
               </p>',
            ],
            [
                'name' => 'CWE-62: UNIX Hard Link',
                'description' => 'The product, when opening a file or directory, does not sufficiently account for when the name is
                associated with a hard link to a target that is outside of the intended control sphere. This could
                allow an attacker to cause the product to operate on unauthorized files.',
                'mitigasi' => '<b>Phase: Architecture and Design</b>
                <p>Strategy = Separation of Privilege</p>
                <pFollow the principle of least privilege when assigning access rights to entities in a software
                system. Denying access to a file can prevent an attacker from replacing that file with a link to a
                sensitive file. Ensure good compartmentalization in the system to provide protected areas that
                can be trusted.
                </p>',
                'reference' => '<p>[REF-62]Mark Dowd, John McDonald and Justin Schuh. "The Art of Software Security
                Assessment". 1st Edition. 2006. Addison Wesley.</p>',
            ],
            [
                'name' => 'CWE-64: Windows Shortcut Following (.LNK)',
                'description' => 'The product, when opening a file or directory, does not sufficiently handle when the file is a
                Windows shortcut (.LNK) whose target is outside of the intended control sphere. This could allow
                an attacker to cause the product to operate on unauthorized files.',
                'mitigasi' => '<b>Phase: Architecture and Design</b>
                <p>Strategy = Separation of Privilege</p>
                <p>Follow the principle of least privilege when assigning access rights to entities in a software
                system. Denying access to a file can prevent an attacker from replacing that file with a link to a
                sensitive file. Ensure good compartmentalization in the system to provide protected areas that
                can be trusted.</p>',
                'reference' => '-',
            ],
            [
                'name' => 'CWE-65: Windows Hard Link',
                'description' => 'The product, when opening a file or directory, does not sufficiently handle when the name is
                associated with a hard link to a target that is outside of the intended control sphere. This could
                allow an attacker to cause the product to operate on unauthorized files.',
                'mitigasi' => '<b>Phase: Architecture and Design</b>
                <p>Strategy = Separation of Privilege</p>
                <p>Follow the principle of least privilege when assigning access rights to entities in a software
                system. Denying access to a file can prevent an attacker from replacing that file with a link to a
                sensitive file. Ensure good compartmentalization in the system to provide protected areas that
                can be trusted.</p>',
                'reference' => '<p>[REF-62]Mark Dowd, John McDonald and Justin Schuh. "The Art of Software Security
                Assessment". 1st Edition. 2006. Addison Wesley.
                </p>',
            ],
            [
                'name' => 'CWE-66: Improper Handling of File Names that Identify Virtual Resources',
                'description' => 'The product does not handle or incorrectly handles a file name that identifies a "virtual" resource
                that is not directly specified within the directory that is associated with the file name, causing the
                product to perform file-based operations on a resource that is not a file.',
                'mitigasi' => '-',
                'reference' => '-',
            ],
            [
                'name' => 'CWE-67: Improper Handling of Windows Device Names',
                'description' => 'The product constructs pathnames from user input, but it does not handle or incorrectly handles a
                pathname containing a Windows device name such as AUX or CON. This typically leads to denial
                of service or an information exposure when the application attempts to process the pathname as a
                regular file.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Be familiar with the device names in the operating system where your system is deployed. Check
                input for these device names</p>',
                'reference' => '<p>[REF-7]Michael Howard and David LeBlanc. "Writing Secure Code". 2nd Edition. 2002
                December 4. Microsoft Press. < https://www.microsoftpressstore.com/store/writing-securecode-9780735617223 >.</p>
                <p>[REF-62]Mark Dowd, John McDonald and Justin Schuh. "The Art of Software Security
                Assessment". 1st Edition. 2006. Addison Wesley.</p>',
            ],
            [
                'name' => 'CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream',
                'description' => 'The product does not properly prevent access to, or detect usage of, alternate data streams (ADS).',
                'mitigasi' => '<b>Phase: Testing
                </b>
                <p>Software tools are capable of finding ADSs on your system</p>
                <b>Phase: Implementation</b>
                <pEnsure that the source code correctly parses the filename to read or write to the correct stream.</p>',
                'reference' => '<p>[REF-562]Don Parker. "Windows NTFS Alternate Data Streams". 2005 February 6. < https://
                seclists.org/basics/2005/Feb/312 >.2023-04-07</p>
                <p>[REF-7]Michael Howard and David LeBlanc. "Writing Secure Code". 2nd Edition. 2002
                December 4. Microsoft Press. < https://www.microsoftpressstore.com/store/writing-securecode-9780735617223 >.
                </p>',
            ],
            [
                'name'=> 'CWE-72: Improper Handling of Apple HFS+ Alternate Data Stream Path',
                'descripton' => 'The product does not properly handle special paths that may identify the data or resource fork of a
                file on the HFS+ file system.',
                'mitigasi' => '-',
                'reference' => '<p>[REF-578]NetSec. "NetSec Security Advisory: Multiple Vulnerabilities Resulting From Use Of Apple
                OSX HFS+". BugTraq. 2005 February 6. < https://seclists.org/bugtraq/2005/Feb/309 >.2023-04-07.</p>',
            ],
            [
                'name' => 'CWE-73: External Control of File Name or Path',
                'description' => 'The product allows user input to control or influence paths or file names that are used in filesystem
                operations.',
                'mitigasi' => '<b>Phase: Architecture and Design</b>
                <p>When the set of filenames is limited or known, create a mapping from a set of fixed input values
                (such as numeric IDs) to the actual filenames, and reject all other inputs. For example, ID
                1 could map to "inbox.txt" and ID 2 could map to "profile.txt". Features such as the ESAPI
                AccessReferenceMap provide this capability.
                </p>
                <b>Phase: Architecture and Design</b>
                <b>Phase: Operation</b>
                <p>Run your code in a "jail" or similar sandbox environment that enforces strict boundaries between
                the process and the operating system. This may effectively restrict all access to files within a
                particular directory. Examples include the Unix chroot jail and AppArmor. In general, managed
                code may provide some protection. This may not be a feasible solution, and it only limits the
                impact to the operating system; the rest of your application may still be subject to compromise.
                Be careful to avoid CWE-243 and other weaknesses related to jails.</p>
                <b>Phase: Architecture and Design</b>
                <p>For any security checks that are performed on the client side, ensure that these checks are
                duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side
                checks by modifying values after the checks have been performed, or by changing the client to
                remove the client-side checks entirely. Then, these modified values would be submitted to the
                server.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may
                be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as "red" or "blue." Do not rely exclusively on
                looking for malicious or malformed inputs. This is likely to miss at least one undesirable input,
                especially if the code`s environment changes. This can give attackers enough room to bypass
                the intended validation. However, denylists can be useful for detecting potential attacks or
                determining which inputs are so malformed that they should be rejected outright. When validating
                filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a
                single "." character in the filename to avoid weaknesses such as CWE-23, and exclude directory
                separators such as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help
                to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially
                dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For
                example, filtering "/" is insufficient protection if the filesystem also supports the use of "\" as a
                directory separator. Another possible error could occur when the filtering is applied in a way that
                still produces dangerous data (CWE-182). For example, if "../" sequences are removed from the
                ".../...//" string in a sequential fashion, two instances of "../" would be removed from the original
                string, but the remaining characters would still form the "../" string.</p>
                <p>Effectiveness = High</p>
                <b>Phase: Implementation</b>
                <p>Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical
                version of the pathname, which effectively removes ".." sequences and symbolic links (CWE-23,
                CWE-59).</p>
                <b>Phase: Installation</b>
                <b>Phase: Operation</b>
                <p>Use OS-level permissions and run as a low-privileged user to limit the scope of any successful
                attack.</p>
                <b>Phase: Operation</b>
                <b>Phase: Implementation</b>
                <p>If you are using PHP, configure your application so that it does not use register_globals. During
                implementation, develop your application so that it does not rely on this feature, but be wary
                of implementing a register_globals emulation that is subject to weaknesses such as CWE-95,
                CWE-621, and similar issues.</p>
                <b>Phase: Testing</b>
                <p>Use tools and techniques that require manual (human) analysis, such as penetration testing,
                threat modeling, and interactive tools that allow the tester to record and modify an active session.
                These may be more effective than strictly automated techniques. This is especially the case with
                weaknesses that are related to design and business rules.</p>',
                'reference' => '<p>[REF-6]Katrina Tsipenyuk, Brian Chess and Gary McGraw. "Seven Pernicious Kingdoms: A
                Taxonomy of Software Security Errors". NIST Workshop on Software Security Assurance Tools
                Techniques and Metrics. 2005 November 7. NIST. < https://samate.nist.gov/SSATTM_Content/
                papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security
                %20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf >.</p>
                <p>[REF-45]OWASP. "OWASP Enterprise Security API (ESAPI) Project". < http://www.owasp.org/
                index.php/ESAPI >.
                </p>',
            ],
            [
                'name' => "CWE-74: Improper Neutralization of Special Elements in Output Used by a
                Downstream Component ('Injection')",
                'description' => 'The product constructs all or part of a command, data structure, or record using externallyinfluenced input from an upstream component, but it does not neutralize or incorrectly neutralizes
                special elements that could modify how it is parsed or interpreted when it is sent to a downstream
                component.',
                'mitigasi' => '<b>Phase: Requirements</b>
                <p>Programming languages and supporting technologies might be chosen which are not subject to
                these issues.</p>
                <b>Phase: Implementation</b>
                <p>Utilize an appropriate mix of allowlist and denylist parsing to filter control-plane syntax from all
                input.</p>',
                'reference' => '<p>[REF-18]Secure Software, Inc.. "The CLASP Application Security Process". 2005. < https://
                cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf >.</p>',
            ],
            [
                'name' => 'CWE-75: Failure to Sanitize Special Elements into a Different Plane (Special
                Element Injection)',
                'description' => 'The product does not adequately filter user-controlled input for special elements with control
                implications.',
                'mitigasi' => '<b>Phase: Requirements</b>
                <p>Programming languages and supporting technologies might be chosen which are not subject to
                these issues.</p>
                <b>Phase: Implementation</b>
                <p>Utilize an appropriate mix of allowlist and denylist parsing to filter special element syntax from all
                input.</p>',
                'reference' => '-',
            ],
            [
                'name' => 'CWE-76: Improper Neutralization of Equivalent Special Elements',
                'description' => 'The product correctly neutralizes certain special elements, but it improperly neutralizes equivalent
                special elements.',
                'mitigasi' => '<b>Phase: Requirements</b>
                <p>Programming languages and supporting technologies might be chosen which are not subject to
                these issues.</p>
                <b>Phase: Implementation</b>
                <p>Utilize an appropriate mix of allowlist and denylist parsing to filter equivalent special element
                syntax from all input.
                </p>',
                'reference' => '-',
            ],
            [
                'name' => "CWE-77: Improper Neutralization of Special Elements used in a Command
                ('Command Injection')",
                'description' => 'The product constructs all or part of a command using externally-influenced input from an upstream
                component, but it does not neutralize or incorrectly neutralizes special elements that could modify
                the intended command when it is sent to a downstream component.',
                'mitigasi' => '<b>Phase: Architecture and Design
                </b>
                <p>If at all possible, use library calls rather than external processes to recreate the desired
                functionality.</p>
                <b>Phase: Implementation</b>
                <p>If possible, ensure that all external commands called from the program are statically created.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may be
                syntactically valid because it only contains alphanumeric characters, but it is not valid if the input
                is only expected to contain colors such as "red" or "blue." Do not rely exclusively on looking for
                malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if
                the code`s environment changes. This can give attackers enough room to bypass the intended
                validation. However, denylists can be useful for detecting potential attacks or determining which
                inputs are so malformed that they should be rejected outright.</p>
                <b>Phase: Operation</b>
                <p>Run time: Run time policy enforcement may be used in an allowlist fashion to prevent use of any
                non-sanctioned commands.</p>
                <b>Phase: System Configuration</b>
                <p>Assign permissions that prevent the user from accessing/opening privileged files.</p>',
                'reference' => '<p>[REF-6]Katrina Tsipenyuk, Brian Chess and Gary McGraw. "Seven Pernicious Kingdoms: A
                Taxonomy of Software Security Errors". NIST Workshop on Software Security Assurance Tools
                Techniques and Metrics. 2005 November 7. NIST. < https://samate.nist.gov/SSATTM_Content/
                papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security
                %20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf >.</p>
                <p>[REF-140]Greg Hoglund and Gary McGraw. "Exploiting Software: How to Break Code". 2004
                February 7. Addison-Wesley. < https://www.amazon.com/Exploiting-Software-How-Break-Code/
                dp/0201786958 >.2023-04-07.</p>
                <p>[REF-44]Michael Howard, David LeBlanc and John Viega. "24 Deadly Sins of Software Security".
                McGraw-Hill. 2010.
                </p>
                <p>[REF-1287]MITRE. "Supplemental Details - 2022 CWE Top 25". 2022 June 8. < https://
                cwe.mitre.org/top25/archive/2022/2022_cwe_top25_supplemental.html#problematicMappingDetails
                >.</p>',
            ],
            [
                'name' => "CWE-78: Improper Neutralization of Special Elements used in an OS Command
                ('OS Command Injection')",
                'description' => 'The product constructs all or part of an OS command using externally-influenced input from an
                upstream component, but it does not neutralize or incorrectly neutralizes special elements that
                could modify the intended OS command when it is sent to a downstream component.',
                'mitigasi' => '<b>Phase: Architecture and Design</b>
                <p>If at all possible, use library calls rather than external processes to recreate the desired
                functionality.</p>
                <b>Phase: Architecture and Design</b>
                <b>Phase: Operation</b>
                <p>Strategy = Sandbox or Jail</p>
                <p>Run the code in a "jail" or similar sandbox environment that enforces strict boundaries between
                the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples
                include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide
                some protection. For example, java.io.FilePermission in the Java SecurityManager allows the
                software to specify restrictions on file operations. This may not be a feasible solution, and it
                only limits the impact to the operating system; the rest of the application may still be subject to
                compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.
                </p>
                <p>Effectiveness = Limited</p>
                <p>The effectiveness of this mitigation depends on the prevention capabilities of the specific
                sandbox or jail being used and might only help to reduce the scope of an attack, such as
                restricting the attacker to certain system calls or limiting the portion of the file system that can be
                accessed.</p>
                <b>Phase: Architecture and Design</b>
                <p>Strategy = Attack Surface Reduction</p>
                <p>For any data that will be used to generate a command to be executed, keep as much of that data
                out of external control as possible. For example, in web applications, this may require storing the
                data locally in the session`s state instead of sending it out to the client in a hidden form field.</p>
                <b>Phase: Architecture and Design</b>
                <p>For any security checks that are performed on the client side, ensure that these checks are
                duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side
                checks by modifying values after the checks have been performed, or by changing the client to
                remove the client-side checks entirely. Then, these modified values would be submitted to the
                server.</p>
                <b>Phase: Architecture and Design</b>
                <p>Strategy = Libraries or Frameworks</p>
                <p>Use a vetted library or framework that does not allow this weakness to occur or provides
                constructs that make this weakness easier to avoid. For example, consider using the
                ESAPI Encoding control [REF-45] or a similar tool, library, or framework. These will help the
                programmer encode outputs in a manner less prone to error.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Output Encoding</p>
                <p>While it is risky to use dynamically-generated query strings, code, or commands that mix control
                and data together, sometimes it may be unavoidable. Properly quote arguments and escape
                any special characters within those arguments. The most conservative approach is to escape or
                filter all characters that do not pass an extremely strict allowlist (such as everything that is not
                alphanumeric or white space). If some special characters are still needed, such as white space,
                wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection
                (CWE-88).</p>
                <b>Phase: Implementation</b>
                <p>If the program to be executed allows arguments to be specified within an input file or from
                standard input, then consider using that mode to pass arguments instead of the command line.</p>
                <b>Phase: Architecture and Design</b>
                <p>Strategy = Parameterization</p>
                <p>If available, use structured mechanisms that automatically enforce the separation between
                data and code. These mechanisms may be able to provide the relevant quoting, encoding,
                and validation automatically, instead of relying on the developer to provide this capability at
                every point where output is generated. Some languages offer multiple functions that can be
                used to invoke commands. Where possible, identify any function that invokes a command shell
                using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the
                system() function accepts a string that contains the entire command to be executed, whereas
                execl(), execve(), and others require an array of strings, one for each argument. In Windows,
                CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an
                array of arguments, then it will quote each of the arguments.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may be
                syntactically valid because it only contains alphanumeric characters, but it is not valid if the input
                is only expected to contain colors such as "red" or "blue." Do not rely exclusively on looking for
                malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if
                the code`s environment changes. This can give attackers enough room to bypass the intended
                validation. However, denylists can be useful for detecting potential attacks or determining
                which inputs are so malformed that they should be rejected outright. When constructing OS
                command strings, use stringent allowlists that limit the character set based on the expected
                value of the parameter in the request. This will indirectly limit the scope of an attack, but this
                technique is less important than proper output encoding and escaping. Note that proper output
                encoding, escaping, and quoting is the most effective solution for preventing OS command
                injection, although input validation may provide some defense-in-depth. This is because it
                effectively limits what will appear in output. Input validation will not always prevent OS command
                injection, especially if you are required to support free-form text fields that could contain arbitrary
                characters. For example, when invoking a mail program, you might need to allow the subject
                field to contain otherwise-dangerous inputs like ";" and ">" characters, which would need to
                be escaped or otherwise handled. In this case, stripping the character might reduce the risk
                of OS command injection, but it would produce incorrect behavior because the subject field
                would not be recorded as the user intended. This might seem to be a minor inconvenience,
                but it could be more important when the program relies on well-structured subject lines in order
                to pass messages to other components. Even if you make a mistake in your validation (such
                as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from
                injection-based attacks. As long as it is not done in isolation, input validation is still a useful
                technique, since it may significantly reduce your attack surface, allow you to detect some attacks,
                and provide other security benefits that proper encoding does not address.</p>
                <b>Phase: Architecture and Design</b>
                <p>Strategy = Enforcement by Conversion</p>
                <p>When the set of acceptable objects, such as filenames or URLs, is limited or known, create a
                mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs,
                and reject all other inputs.</p>
                <b>Phase: Operation</b>
                <p>Strategy = Compilation or Build Hardening</p>
                <p>Run the code in an environment that performs automatic taint propagation and prevents any
                command execution that uses tainted variables, such as Perl`s "-T" switch. This will force the
                program to perform validation steps that remove the taint, although you must be careful to
                correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted
                (see CWE-183 and CWE-184).</p>
                <b>Phase: Operation</b>
                <p>Strategy = Environment Hardening</p>
                <p>Run the code in an environment that performs automatic taint propagation and prevents any
                command execution that uses tainted variables, such as Perl`s "-T" switch. This will force the
                program to perform validation steps that remove the taint, although you must be careful to
                correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted
                (see CWE-183 and CWE-184).</p>
                <b>Phase: Implementation</b>
                <p>Ensure that error messages only contain minimal details that are useful to the intended audience
                and no one else. The messages need to strike the balance between being too cryptic (which
                can confuse users) or being too detailed (which may reveal more than intended). The messages
                should not reveal the methods that were used to determine the error. Attackers can use detailed
                information to refine or optimize their original attack, thereby increasing their chances of success.
                If errors must be captured in some detail, record them in log messages, but consider what
                could occur if the log messages can be viewed by attackers. Highly sensitive information such
                as passwords should never be saved to log files. Avoid inconsistent messaging that might
                accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                In the context of OS Command Injection, error information passed back to the user might reveal
                whether an OS command is being executed and possibly which command is being used.</p>
                <b>Phase: Operation</b>
                <p>Strategy = Sandbox or Jail</p>
                <p>Use runtime policy enforcement to create an allowlist of allowable commands, then prevent
                use of any command that does not appear in the allowlist. Technologies such as AppArmor are
                available to do this.</p>
                <b>Phase: Operation</b>
                <p>Strategy = Firewall</p>
                <p>Use an application firewall that can detect attacks against this weakness. It can be beneficial
                in cases in which the code cannot be fixed (because it is controlled by a third party), as an
                emergency prevention measure while more comprehensive software assurance measures are
                applied, or to provide defense in depth.</p>
                <p>Effectiveness = Moderate</p>
                <p>An application firewall might not cover all possible input vectors. In addition, attack techniques
                might be available to bypass the protection mechanism, such as using malformed inputs that can
                still be processed by the component that receives those inputs. Depending on functionality, an
                application firewall might inadvertently reject or modify legitimate requests. Finally, some manual
                effort may be required for customization.</p>
                <b>Phase: Architecture and Design</b>
                <b>Phase: Operation</b>
                <p>Strategy = Environment Hardening</p>
                <p>Run your code using the lowest privileges that are required to accomplish the necessary tasks
                [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a
                single task. That way, a successful attack will not immediately give the attacker access to the
                rest of the software or its environment. For example, database applications rarely need to run as
                the database administrator, especially in day-to-day operations.</p>
                <b>Phase: Operation</b>
                <b>Phase: Implementation</b>
                <p>Strategy = Environment Hardening</p>
                <p>When using PHP, configure the application so that it does not use register_globals. During
                implementation, develop the application so that it does not rely on this feature, but be wary of
                implementing a register_globals emulation that is subject to weaknesses such as CWE-95,
                CWE-621, and similar issues.</p>',
                'reference' => '<p>[REF-140]Greg Hoglund and Gary McGraw. "Exploiting Software: How to Break Code". 2004
                February 7. Addison-Wesley. < https://www.amazon.com/Exploiting-Software-How-Break-Code/
                dp/0201786958 >.2023-04-07.</p>
                <p>[REF-685]Pascal Meunier. "Meta-Character Vulnerabilities". 2008 February 0. < https://
                web.archive.org/web/20100714032622/https://www.cs.purdue.edu/homes/cs390s/slides/
                week09.pdf >.2023-04-07.</p>
                <p>[REF-686]Robert Auger. "OS Commanding". 2009 June. < http://projects.webappsec.org/w/
                page/13246950/OS%20Commanding >.2023-04-07.
                </p>
                <p>[REF-687]Lincoln Stein and John Stewart. "The World Wide Web Security FAQ". 2002 February 4.
                < https://www.w3.org/Security/Faq/wwwsf4.html >.2023-04-07.
                </p>
                <p>[REF-688]Jordan Dimov, Cigital. "Security Issues in Perl Scripts". < https://www.cgisecurity.com/lib/
                sips.html >.2023-04-07.</p>
                </p>
                <p>[REF-44]Michael Howard, David LeBlanc and John Viega. "24 Deadly Sins of Software Security".
                McGraw-Hill. 2010.
                </p>
                <p>[REF-690]Frank Kim. "Top 25 Series - Rank 9 - OS Command Injection". 2010 February 4. SANS
                Software Security Institute. < https://www.sans.org/blog/top-25-series-rank-9-os-commandinjection/ >.2023-04-07.</p>
                <p>[REF-45]OWASP. "OWASP Enterprise Security API (ESAPI) Project". < http://www.owasp.org/
                index.php/ESAPI >.</p>
                <p>[REF-76]Sean Barnum and Michael Gegick. "Least Privilege". 2005 September 4. < https://
                web.archive.org/web/20211209014121/https://www.cisa.gov/uscert/bsi/articles/knowledge/
                principles/least-privilege >.2023-04-07.</p>
                <p[REF-62]Mark Dowd, John McDonald and Justin Schuh. "The Art of Software Security
                Assessment". 1st Edition. 2006. Addison Wesley.</p>
                <p>[REF-962]Object Management Group (OMG). "Automated Source Code Security Measure
                (ASCSM)". 2016 January. < http://www.omg.org/spec/ASCSM/1.0/ >.
                </p>',
            ],
            [
                'name' => "CWE-79: Improper Neutralization of Input During Web Page Generation('Cross-site Scripting')",
                'description' => 'The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed
                in output that is used as a web page that is served to other users.',
                'mitigasi' => '<b>Phase: Architecture and Design</b>
                <p>Strategy = Libraries or Frameworks</p>
                <p>Use a vetted library or framework that does not allow this weakness to occur or provides
                constructs that make this weakness easier to avoid. Examples of libraries and frameworks that
                make it easier to generate properly encoded output include Microsoft`s Anti-XSS library, the
                OWASP ESAPI Encoding module, and Apache Wicket.</p>
                <b>Phase: Implementation</b>
                <b>Phase: Architecture and Design</b>
                <p>Understand the context in which your data will be used and the encoding that will be expected.
                This is especially important when transmitting data between different components, or when
                generating outputs that can contain multiple encodings at the same time, such as web pages or
                multi-part mail messages. Study all expected communication protocols and data representations
                to determine the required encoding strategies. For any data that will be output to another web
                page, especially any data that was received from external inputs, use the appropriate encoding
                on all non-alphanumeric characters. Parts of the same output document may require different
                encodings, which will vary depending on whether the output is in the: HTML body Element
                attributes (such as src="XYZ") URIs JavaScript sections Cascading Style Sheets and style
                property etc. Note that HTML Entity Encoding is only appropriate for the HTML body. Consult the
                XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping
                that are needed.</p>
                <b>Phase: Architecture and Design</b>
                <b>Phase: Implementation</b>
                <p>Strategy = Attack Surface Reduction</p>
                <p>Understand all the potential areas where untrusted inputs can enter your software: parameters
                or arguments, cookies, anything read from the network, environment variables, reverse DNS
                lookups, query results, request headers, URL components, e-mail, files, filenames, databases,
                and any external systems that provide data to the application. Remember that such inputs may
                be obtained indirectly through API calls.
                </p>
                <p>Effectiveness = Limited</p>
                <p>This technique has limited effectiveness, but can be helpful when it is possible to store client
                state and sensitive information on the server side instead of in cookies, headers, hidden form
                fields, etc.
                </p>
                <b>Phase: Architecture and Design</b>
                <p>For any security checks that are performed on the client side, ensure that these checks are
                duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side
                checks by modifying values after the checks have been performed, or by changing the client to
                remove the client-side checks entirely. Then, these modified values would be submitted to the
                server.</p>
                <b>Phase: Architecture and Design</b>
                <p>Strategy = Parameterization</p>
                <p>If available, use structured mechanisms that automatically enforce the separation between
                data and code. These mechanisms may be able to provide the relevant quoting, encoding, and
                validation automatically, instead of relying on the developer to provide this capability at every
                point where output is generated.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Output Encoding</p>
                <p>Use and specify an output encoding that can be handled by the downstream component that
                is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an
                encoding is not specified, a downstream component may choose a different encoding, either
                by assuming a default encoding or automatically inferring which encoding is being used, which
                can be erroneous. When the encodings are inconsistent, the downstream component might
                treat some character or byte sequences as special, even if they are not special in the original
                encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks;
                they even might be able to bypass protection mechanisms that assume the original encoding is
                also being used by the downstream component. The problem of inconsistent output encodings
                often arises in web pages. If an encoding is not specified in an HTTP header, web browsers
                often guess about which encoding is being used. This can open up the browser to subtle XSS
                attacks</p>
                <b>Phase: Implementation</b>
                <p>With Struts, write all data from form beans with the bean`s filter attribute set to true</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Attack Surface Reduction
                </p>
                <p>To help mitigate XSS attacks against the user`s session cookie, set the session cookie to be
                HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet
                Explorer and Firefox), this attribute can prevent the user`s session cookie from being accessible
                to malicious client-side scripts that use document.cookie. This is not a complete solution, since
                HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other
                powerful browser technologies provide read access to HTTP headers, including the Set-Cookie
                header in which the HttpOnly flag is set.
                </p>
                <p>Effectiveness = Defense in Depth</p>
                <p>Strategy = Input Validation
                </p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may be
                syntactically valid because it only contains alphanumeric characters, but it is not valid if the input
                is only expected to contain colors such as "red" or "blue." Do not rely exclusively on looking for
                malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if
                the code`s environment changes. This can give attackers enough room to bypass the intended
                validation. However, denylists can be useful for detecting potential attacks or determining which
                inputs are so malformed that they should be rejected outright. When dynamically constructing
                web pages, use stringent allowlists that limit the character set based on the expected value of the
                parameter in the request. All input should be validated and cleansed, not just parameters that the
                user is supposed to specify, but all data in the request, including hidden fields, cookies, headers,
                the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is
                to validate only fields that are expected to be redisplayed by the site. It is common to see data
                from the request that is reflected by the application server or the application that the development
                team did not anticipate. Also, a field that is not currently reflected may be used by a future
                developer. Therefore, validating ALL parts of the HTTP request is recommended. Note that
                proper output encoding, escaping, and quoting is the most effective solution for preventing XSS,
                although input validation may provide some defense-in-depth. This is because it effectively limits
                what will appear in output. Input validation will not always prevent XSS, especially if you are
                required to support free-form text fields that could contain arbitrary characters. For example,
                in a chat application, the heart emoticon ("<3") would likely pass the validation step, since it is
                commonly used. However, it cannot be directly inserted into the web page because it contains
                the "<" character, which would need to be escaped or otherwise handled. In this case, stripping
                the "<" might reduce the risk of XSS, but it would produce incorrect behavior because the
                emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be
                more important in a mathematical forum that wants to represent inequalities. Even if you make a
                mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is
                still likely to protect you from injection-based attacks. As long as it is not done in isolation, input
                validation is still a useful technique, since it may significantly reduce your attack surface, allow
                you to detect some attacks, and provide other security benefits that proper encoding does not
                address. Ensure that you perform input validation at well-defined interfaces within the application.
                This will help protect the application even if a component is reused or moved elsewhere.</p>
                <b>Phase: Architecture and Design
                </b>
                <p>Strategy = Enforcement by Conversion</p>
                <p>When the set of acceptable objects, such as filenames or URLs, is limited or known, create a
                mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs,
                and reject all other inputs.</p>
                <b>Phase: Operation</b>
                <p>Strategy = Firewall</p>
                <p>Use an application firewall that can detect attacks against this weakness. It can be beneficial
                in cases in which the code cannot be fixed (because it is controlled by a third party), as an
                emergency prevention measure while more comprehensive software assurance measures are
                applied, or to provide defense in depth.
                </p>
                <p>Effectiveness = Moderate</p>
                <p>An application firewall might not cover all possible input vectors. In addition, attack techniques
                might be available to bypass the protection mechanism, such as using malformed inputs that can still be processed by the component that receives those inputs. Depending on functionality, an
                application firewall might inadvertently reject or modify legitimate requests. Finally, some manual
                effort may be required for customization.</p>
                <b>Phase: Operation</b>
                <b>Phase: Implementation</b>
                <p>Strategy = Environment Hardening</p>
                <p>When using PHP, configure the application so that it does not use register_globals. During
                implementation, develop the application so that it does not rely on this feature, but be wary of
                implementing a register_globals emulation that is subject to weaknesses such as CWE-95,
                CWE-621, and similar issues.</p>',
                'reference' => '<p>[REF-709]Jeremiah Grossman, Robert "RSnake" Hansen, Petko "pdp" D. Petkov, Anton Rager and
                Seth Fogie. "XSS Attacks". 2007. Syngress.
                </p>
                <p>[REF-44]Michael Howard, David LeBlanc and John Viega. "24 Deadly Sins of Software Security".
                McGraw-Hill. 2010.</p>
                <p>[REF-44]Michael Howard, David LeBlanc and John Viega. "24 Deadly Sins of Software Security".
                McGraw-Hill. 2010.</p>
                <p>[REF-712]"Cross-site scripting". 2008 August 6. Wikipedia. < https://en.wikipedia.org/wiki/Crosssite_scripting >.2023-04-07.</p>
                <p>[REF-7]Michael Howard and David LeBlanc. "Writing Secure Code". 2nd Edition. 2002
                December 4. Microsoft Press. < https://www.microsoftpressstore.com/store/writing-securecode-9780735617223 >.</p>
                <p>[REF-714]RSnake. "XSS (Cross Site Scripting) Cheat Sheet". < http://ha.ckers.org/xss.html ></p>
                <p>[REF-715]Microsoft. "Mitigating Cross-site Scripting With HTTP-only Cookies". < https://
                learn.microsoft.com/en-us/previous-versions//ms533046(v=vs.85)?redirectedfrom=MSDN
                >.2023-04-07.</p>
                <p>[REF-716]Mark Curphey, Microsoft. "Anti-XSS 3.0 Beta and CAT.NET Community Technology
                Preview now Live!". < https://learn.microsoft.com/en-us/archive/blogs/cisg/anti-xss-3-0-beta-andcat-net-community-technology-preview-now-live >.2023-04-07.</p>
                <p>[REF-45]OWASP. "OWASP Enterprise Security API (ESAPI) Project". < http://www.owasp.org/
                index.php/ESAPI >.</p>
                <p>[REF-718]Ivan Ristic. "XSS Defense HOWTO". < https://www.trustwave.com/en-us/resources/
                blogs/spiderlabs-blog/xss-defense-howto/ >.2023-04-07.</p>
                <p>[REF-719]OWASP. "Web Application Firewall". < http://www.owasp.org/index.php/
                Web_Application_Firewall >.</p>
                <p>[REF-720]Web Application Security Consortium. "Web Application Firewall Evaluation Criteria". <
                http://projects.webappsec.org/w/page/13246985/Web%20Application%20Firewall%20Evaluation
                %20Criteria >.2023-04-07.</p>
                <p>[REF-721]RSnake. "Firefox Implements httpOnly And is Vulnerable to XMLHTTPRequest". 2007
                July 9.</p>
                <p>[REF-722]"XMLHttpRequest allows reading HTTPOnly cookies". Mozilla. < https://
                bugzilla.mozilla.org/show_bug.cgi?id=380418 >.
                </p>
                <p>[REF-723]"Apache Wicket". < http://wicket.apache.org/ >.</p>
                <p>[REF-724]OWASP. "XSS (Cross Site Scripting) Prevention Cheat Sheet". < http://www.owasp.org/
                index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet >.</p>
                <p>[REF-725]OWASP. "DOM based XSS Prevention Cheat Sheet". < http://www.owasp.org/index.php/
                DOM_based_XSS_Prevention_Cheat_Sheet >.</p>
                <p>[REF-726]Jason Lam. "Top 25 series - Rank 1 - Cross Site Scripting". 2010 February 2. SANS
                Software Security Institute. < https://www.sans.org/blog/top-25-series-rank-1-cross-site-scripting/
                >.2023-04-07.
                </p>
                <p>[REF-62]Mark Dowd, John McDonald and Justin Schuh. "The Art of Software Security
                Assessment". 1st Edition. 2006. Addison Wesley.</p>
                <p>[REF-956]Wikipedia. "Samy (computer worm)". < https://en.wikipedia.org/wiki/
                Samy_(computer_worm) >.2018-01-16.</p>
                <p>[REF-962]Object Management Group (OMG). "Automated Source Code Security Measure
                (ASCSM)". 2016 January. < http://www.omg.org/spec/ASCSM/1.0/ >.</p>',
            ],
            [
                'name' => 'CWE-80: Improper Neutralization of Script-Related HTML Tags in a Web Page
                (Basic XSS)',
                'description' => 'The product receives input from an upstream component, but it does not neutralize or incorrectly
                neutralizes special characters such as "<", ">", and "&" that could be interpreted as web-scripting
                elements when they are sent to a downstream component that processes web pages.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Carefully check each input parameter against a rigorous positive specification (allowlist) defining
                the specific characters and format allowed. All input should be neutralized, not just parameters
                that the user is supposed to specify, but all data in the request, including hidden fields,
                cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS
                vulnerabilities is to validate only fields that are expected to be redisplayed by the site. We often
                encounter data from the request that is reflected by the application server or the application that
                the development team did not anticipate. Also, a field that is not currently reflected may be used
                by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Output Encoding</p>
                <p>Use and specify an output encoding that can be handled by the downstream component that
                is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an
                encoding is not specified, a downstream component may choose a different encoding, either
                by assuming a default encoding or automatically inferring which encoding is being used, which
                can be erroneous. When the encodings are inconsistent, the downstream component might
                treat some character or byte sequences as special, even if they are not special in the original
                encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks;
                they even might be able to bypass protection mechanisms that assume the original encoding is
                also being used by the downstream component. The problem of inconsistent output encodings
                often arises in web pages. If an encoding is not specified in an HTTP header, web browsers
                often guess about which encoding is being used. This can open up the browser to subtle XSS
                attacks.</p>
                <b>Phase: Implementation</b>
                <p>With Struts, write all data from form beans with the bean`s filter attribute set to true.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Attack Surface Reduction</p>
                <p>To help mitigate XSS attacks against the user`s session cookie, set the session cookie to be
                HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet
                Explorer and Firefox), this attribute can prevent the user`s session cookie from being accessible
                to malicious client-side scripts that use document.cookie. This is not a complete solution, since
                HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other
                powerful browser technologies provide read access to HTTP headers, including the Set-Cookie
                header in which the HttpOnly flag is set.
                </p>
                <p>Effectiveness = Defense in Depth
                </p>',
                'reference' => '-',
            ],
            [
                'name' => 'CWE-81: Improper Neutralization of Script in an Error Message Web Page',
                'description' => 'The product receives input from an upstream component, but it does not neutralize or incorrectly
                neutralizes special characters that could be interpreted as web-scripting elements when they are
                sent to an error page.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Do not write user-controlled input to error pages.</p>
                <b>Phase: Implementation
                </b>
                <p>Carefully check each input parameter against a rigorous positive specification (allowlist) defining
                the specific characters and format allowed. All input should be neutralized, not just parameters
                that the user is supposed to specify, but all data in the request, including hidden fields,
                cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS
                vulnerabilities is to validate only fields that are expected to be redisplayed by the site. We often
                encounter data from the request that is reflected by the application server or the application that
                the development team did not anticipate. Also, a field that is not currently reflected may be used
                by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.</p>
                <b>Phase: Implementation
                </b>
                <p>Strategy = Output Encoding</p>
                <p>Use and specify an output encoding that can be handled by the downstream component that
                is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an
                encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which
                can be erroneous. When the encodings are inconsistent, the downstream component might
                treat some character or byte sequences as special, even if they are not special in the original
                encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks;
                they even might be able to bypass protection mechanisms that assume the original encoding is
                also being used by the downstream component. The problem of inconsistent output encodings
                often arises in web pages. If an encoding is not specified in an HTTP header, web browsers
                often guess about which encoding is being used. This can open up the browser to subtle XSS
                attacks.</p>
                <b>Phase: Implementation</b>
                <p>With Struts, write all data from form beans with the bean`s filter attribute set to true</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Attack Surface Reduction</p>
                <p>To help mitigate XSS attacks against the user`s session cookie, set the session cookie to be
                HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet
                Explorer and Firefox), this attribute can prevent the user`s session cookie from being accessible
                to malicious client-side scripts that use document.cookie. This is not a complete solution, since
                HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other
                powerful browser technologies provide read access to HTTP headers, including the Set-Cookie
                header in which the HttpOnly flag is set.</p>
                <p>Effectiveness = Defense in Depth</p>',
                'reference' => '<p>[REF-44]Michael Howard, David LeBlanc and John Viega. "24 Deadly Sins of Software Security".
                McGraw-Hill. 2010.</p>',
            ],
            [
                'name' => 'CWE-82: Improper Neutralization of Script in Attributes of IMG Tags in a Web
                Page',
                'description' =>'The web application does not neutralize or incorrectly neutralizes scripting elements within
                attributes of HTML IMG tags, such as the src attribute.',
                'mitigasi' => '<b>Phase: Implementation
                </b>
                <p>Strategy = Output Encoding</p>
                <p>Use and specify an output encoding that can be handled by the downstream component that
                is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an
                encoding is not specified, a downstream component may choose a different encoding, either
                by assuming a default encoding or automatically inferring which encoding is being used, which
                can be erroneous. When the encodings are inconsistent, the downstream component might
                treat some character or byte sequences as special, even if they are not special in the original
                encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks;
                they even might be able to bypass protection mechanisms that assume the original encoding is
                also being used by the downstream component. The problem of inconsistent output encodings
                often arises in web pages. If an encoding is not specified in an HTTP header, web browsers
                often guess about which encoding is being used. This can open up the browser to subtle XSS
                attacks</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Attack Surface Reduction</p>
                <p>To help mitigate XSS attacks against the user`s session cookie, set the session cookie to be
                HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user`s session cookie from being accessible
                to malicious client-side scripts that use document.cookie. This is not a complete solution, since
                HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other
                powerful browser technologies provide read access to HTTP headers, including the Set-Cookie
                header in which the HttpOnly flag is set.</p>
                <p>Effectiveness = Defense in Depth</p>',
                'reference' => '-',
            ],
            [
                'name' => 'CWE-83: Improper Neutralization of Script in Attributes in a Web Page',
                'description' => 'The product does not neutralize or incorrectly neutralizes "javascript:" or other URIs from
                dangerous attributes within tags, such as onmouseover, onload, onerror, or style.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Carefully check each input parameter against a rigorous positive specification (allowlist) defining
                the specific characters and format allowed. All input should be neutralized, not just parameters
                that the user is supposed to specify, but all data in the request, including tag attributes, hidden
                fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing
                XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site.
                We often encounter data from the request that is reflected by the application server or the
                application that the development team did not anticipate. Also, a field that is not currently
                reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP
                request is recommended.
                </p>
                <b>Phase: Implementation</b>
                <p>Strategy = Output Encoding</p>
                <p>Use and specify an output encoding that can be handled by the downstream component that
                is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an
                encoding is not specified, a downstream component may choose a different encoding, either
                by assuming a default encoding or automatically inferring which encoding is being used, which
                can be erroneous. When the encodings are inconsistent, the downstream component might
                treat some character or byte sequences as special, even if they are not special in the original
                encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks;
                they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component. The problem of inconsistent output encodings
                often arises in web pages. If an encoding is not specified in an HTTP header, web browsers
                often guess about which encoding is being used. This can open up the browser to subtle XSS
                attacks.</p>
                <b>Phase: Implementation</b>
                <p>With Struts, write all data from form beans with the bean`s filter attribute set to true.</p>
                <b>Phase: Implementation
                </b>
                <p>Strategy = Attack Surface Reduction</p>
                <p>To help mitigate XSS attacks against the user`s session cookie, set the session cookie to be
                HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet
                Explorer and Firefox), this attribute can prevent the user`s session cookie from being accessible
                to malicious client-side scripts that use document.cookie. This is not a complete solution, since
                HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other
                powerful browser technologies provide read access to HTTP headers, including the Set-Cookie
                header in which the HttpOnly flag is set.</p>
                <p>Effectiveness = Defense in Depth
                </p>',
                'reference' => '-',
            ],
            [
                'name' => 'CWE-84: Improper Neutralization of Encoded URI Schemes in a Web Page',
                'description' => 'The web application improperly neutralizes user-controlled input for executable script disguised
                with URI encodings.',
                'mitigasi' => '<b>Phase: Implementation
                </b>
                <p>Strategy = Input Validation</p>
                <p>Resolve all URIs to absolute or canonical representations before processing.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Carefully check each input parameter against a rigorous positive specification (allowlist) defining
                the specific characters and format allowed. All input should be neutralized, not just parameters
                that the user is supposed to specify, but all data in the request, including tag attributes, hidden
                fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing
                XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site.
                We often encounter data from the request that is reflected by the application server or the
                application that the development team did not anticipate. Also, a field that is not currently
                reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP
                request is recommended.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Output Encoding</p>
                <p>Use and specify an output encoding that can be handled by the downstream component that
                is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an
                encoding is not specified, a downstream component may choose a different encoding, either
                by assuming a default encoding or automatically inferring which encoding is being used, which
                can be erroneous. When the encodings are inconsistent, the downstream component might
                treat some character or byte sequences as special, even if they are not special in the original
                encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks;
                they even might be able to bypass protection mechanisms that assume the original encoding is
                also being used by the downstream component. The problem of inconsistent output encodings
                often arises in web pages. If an encoding is not specified in an HTTP header, web browsers
                often guess about which encoding is being used. This can open up the browser to subtle XSS
                attacks.
                </p>
                <b>Phase: Implementation</b>
                <p>With Struts, write all data from form beans with the bean`s filter attribute set to true.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Attack Surface Reduction</p>
                <p>To help mitigate XSS attacks against the user`s session cookie, set the session cookie to be
                HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet
                Explorer and Firefox), this attribute can prevent the user`s session cookie from being accessible
                to malicious client-side scripts that use document.cookie. This is not a complete solution, since
                HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other
                powerful browser technologies provide read access to HTTP headers, including the Set-Cookie
                header in which the HttpOnly flag is set.
                </p>
                <p>Effectiveness = Defense in Depth</p>',
                'reference' => '-',
            ],
            [
                'name' => 'CWE-85: Doubled Character XSS Manipulations',
                'description' => 'The web application does not filter user-controlled input for executable script disguised using
                doubling of the involved characters.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Resolve all filtered input to absolute or canonical representations before processing</p>
                <b>Phase: Implementation
                </b>
                <p>Carefully check each input parameter against a rigorous positive specification (allowlist) defining
                the specific characters and format allowed. All input should be neutralized, not just parameters
                that the user is supposed to specify, but all data in the request, including tag attributes, hidden
                fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing
                XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site.
                We often encounter data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently
                reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP
                request is recommended.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Output Encoding</p>
                <p>Use and specify an output encoding that can be handled by the downstream component that
                is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an
                encoding is not specified, a downstream component may choose a different encoding, either
                by assuming a default encoding or automatically inferring which encoding is being used, which
                can be erroneous. When the encodings are inconsistent, the downstream component might
                treat some character or byte sequences as special, even if they are not special in the original
                encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks;
                they even might be able to bypass protection mechanisms that assume the original encoding is
                also being used by the downstream component. The problem of inconsistent output encodings
                often arises in web pages. If an encoding is not specified in an HTTP header, web browsers
                often guess about which encoding is being used. This can open up the browser to subtle XSS
                attacks</p>
                <b>Phase: Implementation</b>
                <p>With Struts, write all data from form beans with the bean`s filter attribute set to true</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Attack Surface Reduction</p>
                <p>To help mitigate XSS attacks against the user`s session cookie, set the session cookie to be
                HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet
                Explorer and Firefox), this attribute can prevent the user`s session cookie from being accessible
                to malicious client-side scripts that use document.cookie. This is not a complete solution, since
                HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other
                powerful browser technologies provide read access to HTTP headers, including the Set-Cookie
                header in which the HttpOnly flag is set.</p>
                <p>Effectiveness = Defense in Depth
                </p>',
                'reference' => '-',
            ],
            [
                'name' => 'CWE-86: Improper Neutralization of Invalid Characters in Identifiers in Web
                Pages',
                'description' => 'The product does not neutralize or incorrectly neutralizes invalid characters or byte sequences in
                the middle of tag names, URI schemes, and other identifiers.',
                'mitigasi' => '<b>Phase: Implementation
                </b>
                <p>Strategy = Output Encoding</p>
                <p>Use and specify an output encoding that can be handled by the downstream component that
                is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an
                encoding is not specified, a downstream component may choose a different encoding, either
                by assuming a default encoding or automatically inferring which encoding is being used, which
                can be erroneous. When the encodings are inconsistent, the downstream component might
                treat some character or byte sequences as special, even if they are not special in the original
                encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks;
                they even might be able to bypass protection mechanisms that assume the original encoding is
                also being used by the downstream component. The problem of inconsistent output encodings
                often arises in web pages. If an encoding is not specified in an HTTP header, web browsers
                often guess about which encoding is being used. This can open up the browser to subtle XSS
                attacks.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Attack Surface Reduction
                </p>
                <p>To help mitigate XSS attacks against the user`s session cookie, set the session cookie to be
                HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet
                Explorer and Firefox), this attribute can prevent the user`s session cookie from being accessible
                to malicious client-side scripts that use document.cookie. This is not a complete solution, since
                HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other
                powerful browser technologies provide read access to HTTP headers, including the Set-Cookie
                header in which the HttpOnly flag is set.</p>
                <p>Effectiveness = Defense in Depth
                </p>',
                'reference'=> '-',
            ],
            [
                'name' => 'CWE-87: Improper Neutralization of Alternate XSS Syntax',
                'description' => 'The product does not neutralize or incorrectly neutralizes user-controlled input for alternate script
                syntax.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Resolve all input to absolute or canonical representations before processing.</p>
                <b>Phase: Implementation</b>
                <p>Carefully check each input parameter against a rigorous positive specification (allowlist) defining
                the specific characters and format allowed. All input should be neutralized, not just parameters
                that the user is supposed to specify, but all data in the request, including tag attributes, hidden
                fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing
                XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site.
                We often encounter data from the request that is reflected by the application server or the
                application that the development team did not anticipate. Also, a field that is not currently
                reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP
                request is recommended.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Output Encoding
                </p>
                <p>Use and specify an output encoding that can be handled by the downstream component that
                is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an
                encoding is not specified, a downstream component may choose a different encoding, either
                by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might
                treat some character or byte sequences as special, even if they are not special in the original
                encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks;
                they even might be able to bypass protection mechanisms that assume the original encoding is
                also being used by the downstream component. The problem of inconsistent output encodings
                often arises in web pages. If an encoding is not specified in an HTTP header, web browsers
                often guess about which encoding is being used. This can open up the browser to subtle XSS
                attacks</p>
                <b>Phase: Implementation</b>
                <p>With Struts, write all data from form beans with the bean`s filter attribute set to true.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Attack Surface Reduction</p>
                <p>To help mitigate XSS attacks against the user`s session cookie, set the session cookie to be
                HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet
                Explorer and Firefox), this attribute can prevent the user`s session cookie from being accessible
                to malicious client-side scripts that use document.cookie. This is not a complete solution, since
                HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other
                powerful browser technologies provide read access to HTTP headers, including the Set-Cookie
                header in which the HttpOnly flag is set.</p>
                <p>Effectiveness = Defense in Depth
                </p>',
                'reference' => '-',
            ],
            [
                'name' => "CWE-88: Improper Neutralization of Argument Delimiters in a Command
                ('Argument Injection')",
                'description' => 'The product constructs a string for a command to be executed by a separate component in another
                control sphere, but it does not properly delimit the intended arguments, options, or switches within
                that command string.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Parameterization</p>
                <p>Where possible, avoid building a single string that contains the command and its arguments.
                Some languages or frameworks have functions that support specifying independent arguments,
                e.g. as an array, which is used to automatically perform the appropriate quoting or escaping
                while building the command. For example, in PHP, escapeshellarg() can be used to escape a
                single argument to system(), or exec() can be called with an array of arguments. In C, code can
                often be refactored from using system() - which accepts a single string - to using exec(), which
                requires separate function arguments for each parameter.</p>
                <p>Effectiveness = High</p>
                <b>Phase: Architecture and Design</b>
                <p>Strategy = Input Validation</p>
                <p>Understand all the potential areas where untrusted inputs can enter your product: parameters
                or arguments, cookies, anything read from the network, environment variables, request headers
                as well as content, URL components, e-mail, files, databases, and any external systems that
                provide data to the application. Perform input validation at well-defined interfaces.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may be
                syntactically valid because it only contains alphanumeric characters, but it is not valid if the input
                is only expected to contain colors such as "red" or "blue." Do not rely exclusively on looking for
                malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if
                the code`s environment changes. This can give attackers enough room to bypass the intended
                validation. However, denylists can be useful for detecting potential attacks or determining which
                inputs are so malformed that they should be rejected outright.</p>
                <b>Phase: Implementation</b>
                <p>Directly convert your input type into the expected data type, such as using a conversion function
                that translates a string into a number. After converting to the expected data type, ensure that the
                input`s values fall within the expected range of allowable values and that multi-field consistencies
                are maintained.</p>
                <b>Phase: Implementation</b>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180, CWE-181). Make sure that your application does not
                inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass
                allowlist schemes by introducing dangerous inputs after they have been checked. Use
                libraries such as the OWASP ESAPI Canonicalization control. Consider performing repeated
                canonicalization until your input does not change any more. This will avoid double-decoding and
                similar scenarios, but it might inadvertently modify inputs that are allowed to contain properlyencoded dangerous content.</p>
                <b>Phase: Implementation</b>
                <p>When exchanging data between components, ensure that both components are using the same
                character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set
                the encoding you are using whenever the protocol allows you to do so.
                </p>
                <b>Phase: Implementation</b>
                <p>When your application combines data from multiple sources, perform the validation after the
                sources have been combined. The individual data elements may pass the validation step but
                violate the intended restrictions after they have been combined.</p>
                <b>Phase: Testing</b>
                <p>Use automated static analysis tools that target this type of weakness. Many modern techniques
                use data flow analysis to minimize the number of false positives. This is not a perfect solution,
                since 100% accuracy and coverage are not feasible.
                </p>
                <b>Phase: Testing</b>
                <p>Use dynamic tools and techniques that interact with the product using large test suites with
                many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The
                product`s operation may slow down, but it should not become unstable, crash, or generate
                incorrect results.</p>',
                'refrence' => '<p>[REF-859]Steven Christey. "Argument injection issues". < https://seclists.org/bugtraq/2007/
                Feb/234ed >.2023-04-07.
                </p>
                <p>[REF-62]Mark Dowd, John McDonald and Justin Schuh. "The Art of Software Security
                Assessment". 1st Edition. 2006. Addison Wesley.</p>
                <p>[REF-1030]Eldar Marcussen. "Security issues with using PHP`s escapeshellarg". 2013 November
                3. < https://baesystemsai.blogspot.com/2013/11/security-issues-with-using-phps.html >.</p>
                <p>[REF-1249]Dawid Golunski. "PHPMailer < 5.2.18 Remote Code Execution [CVE-2016-10033]".
                2016 December 5. < https://legalhackers.com/advisories/PHPMailer-Exploit-Remote-Code-ExecCVE-2016-10033-Vuln.html >.</p>
                <p>[REF-1250]Dawid Golunski. "Pwning PHP mail() function For Fun And RCE". 2017 May 3. < https://
                exploitbox.io/paper/Pwning-PHP-Mail-Function-For-Fun-And-RCE.html >.
                </p>',
            ],
            [
                'name' => "CWE-89: Improper Neutralization of Special Elements used in an SQL
                Command ('SQL Injection')",
                'description' => 'The product constructs all or part of an SQL command using externally-influenced input from an
                upstream component, but it does not neutralize or incorrectly neutralizes special elements that
                could modify the intended SQL command when it is sent to a downstream component.',
                'mitigasi'=> '<b>Phase: Architecture and Design</b>
                <p>Strategy = Libraries or Frameworks</p>
                <p>Use a vetted library or framework that does not allow this weakness to occur or provides
                constructs that make this weakness easier to avoid. For example, consider using persistence
                layers such as Hibernate or Enterprise Java Beans, which can provide significant protection
                against SQL injection if used properly.
                </p>
                <b>Phase: Architecture and Design
                </b>
                <p>Strategy = Parameterization</p>
                <p>If available, use structured mechanisms that automatically enforce the separation between
                data and code. These mechanisms may be able to provide the relevant quoting, encoding,
                and validation automatically, instead of relying on the developer to provide this capability at
                every point where output is generated. Process SQL queries using prepared statements,
                parameterized queries, or stored procedures. These features should accept parameters or
                variables and support strong typing. Do not dynamically construct and execute query strings
                within these features using "exec" or similar functionality, since this may re-introduce the
                possibility of SQL injection. [REF-867]
                </p>
                <b>Phase: Architecture and Design</b>
                <b>Phase: Operation</b>
                <p>Strategy = Environment Hardening
                </p>
                <p>Run your code using the lowest privileges that are required to accomplish the necessary tasks
                [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a
                single task. That way, a successful attack will not immediately give the attacker access to the
                rest of the software or its environment. For example, database applications rarely need to run as
                the database administrator, especially in day-to-day operations. Specifically, follow the principle
                of least privilege when creating user accounts to a SQL database. The database users should
                only have the minimum privileges necessary to use their account. If the requirements of the
                system indicate that a user can read and modify their own data, then limit their privileges so they
                cannot read/write others` data. Use the strictest permissions possible on all database objects,
                such as execute-only for stored procedures.
                </p>
                <b>Phase: Architecture and Design</b>
                <p>For any security checks that are performed on the client side, ensure that these checks are
                duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side
                checks by modifying values after the checks have been performed, or by changing the client to
                remove the client-side checks entirely. Then, these modified values would be submitted to the
                server.</p>
                <b>Phase: Implementation
                </b>
                <p>Strategy = Output Encoding</p>
                <p>While it is risky to use dynamically-generated query strings, code, or commands that mix control
                and data together, sometimes it may be unavoidable. Properly quote arguments and escape
                any special characters within those arguments. The most conservative approach is to escape
                or filter all characters that do not pass an extremely strict allowlist (such as everything that is
                not alphanumeric or white space). If some special characters are still needed, such as white
                space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument
                injection (CWE-88). Instead of building a new implementation, such features may be available
                in the database or programming language. For example, the Oracle DBMS_ASSERT package
                can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is available in both C
                and PHP.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may be
                syntactically valid because it only contains alphanumeric characters, but it is not valid if the input
                is only expected to contain colors such as "red" or "blue." Do not rely exclusively on looking for
                malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if
                the code`s environment changes. This can give attackers enough room to bypass the intended
                validation. However, denylists can be useful for detecting potential attacks or determining which
                inputs are so malformed that they should be rejected outright. When constructing SQL query
                strings, use stringent allowlists that limit the character set based on the expected value of the
                parameter in the request. This will indirectly limit the scope of an attack, but this technique is
                less important than proper output encoding and escaping. Note that proper output encoding,
                escaping, and quoting is the most effective solution for preventing SQL injection, although input
                validation may provide some defense-in-depth. This is because it effectively limits what will
                appear in output. Input validation will not always prevent SQL injection, especially if you are
                required to support free-form text fields that could contain arbitrary characters. For example,
                the name "O`Reilly" would likely pass the validation step, since it is a common last name in the
                English language. However, it cannot be directly inserted into the database because it contains
                the "`" apostrophe character, which would need to be escaped or otherwise handled. In this
                case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce
                incorrect behavior because the wrong name would be recorded. When feasible, it may be safest
                to disallow meta-characters entirely, instead of escaping them. This will provide some defense in
                depth. After the data is entered into the database, later processes may neglect to escape metacharacters before use, and you may not have control over those processes.</p>
                <b>Phase: Architecture and Design</b>
                <p>Strategy = Enforcement by Conversion
                </p>
                <p>When the set of acceptable objects, such as filenames or URLs, is limited or known, create a
                mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs,
                and reject all other inputs.</p>
                <b>Phase: Implementation</b>
                <p>Ensure that error messages only contain minimal details that are useful to the intended audience
                and no one else. The messages need to strike the balance between being too cryptic (which
                can confuse users) or being too detailed (which may reveal more than intended). The messages
                should not reveal the methods that were used to determine the error. Attackers can use detailed
                information to refine or optimize their original attack, thereby increasing their chances of success.
                If errors must be captured in some detail, record them in log messages, but consider what
                could occur if the log messages can be viewed by attackers. Highly sensitive information such
                as passwords should never be saved to log files. Avoid inconsistent messaging that might
                accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                In the context of SQL Injection, error messages revealing the structure of a SQL query can help
                attackers tailor successful attack strings.
                </p>
                <b>Phase: Operation</b>
                <p>Strategy = Firewall</p>
                <p>Use an application firewall that can detect attacks against this weakness. It can be beneficial
                in cases in which the code cannot be fixed (because it is controlled by a third party), as an
                emergency prevention measure while more comprehensive software assurance measures are
                applied, or to provide defense in depth.</p>
                <p>Effectiveness = Moderate
                </p>
                <p>An application firewall might not cover all possible input vectors. In addition, attack techniques
                might be available to bypass the protection mechanism, such as using malformed inputs that can
                still be processed by the component that receives those inputs. Depending on functionality, an
                application firewall might inadvertently reject or modify legitimate requests. Finally, some manual
                effort may be required for customization.
                </p>
                <b>Phase: Operation</b>
                <b>Phase: Implementation</b>
                <p>Strategy = Environment Hardening</p>
                <p>When using PHP, configure the application so that it does not use register_globals. During
                implementation, develop the application so that it does not rely on this feature, but be wary of
                implementing a register_globals emulation that is subject to weaknesses such as CWE-95,
                CWE-621, and similar issues.</p>',
                'reference' => '<p>[REF-44]Michael Howard, David LeBlanc and John Viega. "24 Deadly Sins of Software Security".
                McGraw-Hill. 2010.</p>
                <p>[REF-7]Michael Howard and David LeBlanc. "Writing Secure Code". 2nd Edition. 2002
                December 4. Microsoft Press. < https://www.microsoftpressstore.com/store/writing-securecode-9780735617223 >.
                </p>
                <p>[REF-867]OWASP. "SQL Injection Prevention Cheat Sheet". < http://www.owasp.org/index.php/
                SQL_Injection_Prevention_Cheat_Sheet >.</p>
                <p[REF-868]Steven Friedl. "SQL Injection Attacks by Example". 2007 October 0. < http://
                www.unixwiz.net/techtips/sql-injection.html >.</p>
                <p>[REF-869]Ferruh Mavituna. "SQL Injection Cheat Sheet". 2007 March 5. < https://web.archive.org/
                web/20080126180244/http://ferruh.mavituna.com/sql-injection-cheatsheet-oku/ >.2023-04-07.
                </p>
                <p>[REF-870]David Litchfield, Chris Anley, John Heasman and Bill Grindlay. "The Database Hacker`s
                Handbook: Defending Database Servers". 2005 July 4. Wiley.</p>
                <p>[REF-871]David Litchfield. "The Oracle Hacker`s Handbook: Hacking and Defending Oracle". 2007
                January 0. Wiley.</p>
                <p>[REF-872]Microsoft. "SQL Injection". 2008 December. < https://learn.microsoft.com/en-us/previousversions/sql/sql-server-2008-r2/ms161953(v=sql.105)?redirectedfrom=MSDN >.2023-04-07.</p>
                <p>[REF-873]Microsoft Security Vulnerability Research & Defense. "SQL Injection Attack". < https://
                msrc.microsoft.com/blog/2008/05/sql-injection-attack/ >.2023-04-07.</p>
                <p>[REF-874]Michael Howard. "Giving SQL Injection the Respect it Deserves". 2008 May 5. < https://
                learn.microsoft.com/en-us/archive/blogs/michael_howard/giving-sql-injection-the-respect-itdeserves >.2023-04-07.</p>
                <p>[REF-875]Frank Kim. "Top 25 Series - Rank 2 - SQL Injection". 2010 March 1. SANS Software
                Security Institute. < https://www.sans.org/blog/top-25-series-rank-2-sql-injection/ >.2023-04-07.</p>
                <p>[REF-76]Sean Barnum and Michael Gegick. "Least Privilege". 2005 September 4. < https://
                web.archive.org/web/20211209014121/https://www.cisa.gov/uscert/bsi/articles/knowledge/
                principles/least-privilege >.2023-04-07.</p>
                <p>[REF-62]Mark Dowd, John McDonald and Justin Schuh. "The Art of Software Security
                Assessment". 1st Edition. 2006. Addison Wesley.
                </p>
                <p>[REF-62]Mark Dowd, John McDonald and Justin Schuh. "The Art of Software Security
                Assessment". 1st Edition. 2006. Addison Wesley.</p>
                <p>[REF-962]Object Management Group (OMG). "Automated Source Code Security Measure
                (ASCSM)". 2016 January. < http://www.omg.org/spec/ASCSM/1.0/ >.
                </p>',
            ],
            [
                'name' => "CWE-90: Improper Neutralization of Special Elements used in an LDAP Query
                ('LDAP Injection')",
                'description' => 'The product constructs all or part of an LDAP query using externally-influenced input from an
                upstream component, but it does not neutralize or incorrectly neutralizes special elements that
                could modify the intended LDAP query when it is sent to a downstream component.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may be
                syntactically valid because it only contains alphanumeric characters, but it is not valid if the input
                is only expected to contain colors such as "red" or "blue." Do not rely exclusively on looking for
                malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if
                the code`s environment changes. This can give attackers enough room to bypass the intended
                validation. However, denylists can be useful for detecting potential attacks or determining which
                inputs are so malformed that they should be rejected outright.
                </p>',
                'reference' => '<p>[REF-879]SPI Dynamics. "Web Applications and LDAP Injection"</p>',
            ],
            [
                'name' => 'CWE-91: XML Injection (aka Blind XPath Injection)',
                'description' => 'The product does not properly neutralize special elements that are used in XML, allowing attackers
                to modify the syntax, content, or commands of the XML before it is processed by an end system.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may be
                syntactically valid because it only contains alphanumeric characters, but it is not valid if the input
                is only expected to contain colors such as "red" or "blue." Do not rely exclusively on looking for
                malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if
                the code`s environment changes. This can give attackers enough room to bypass the intended
                validation. However, denylists can be useful for detecting potential attacks or determining which
                inputs are so malformed that they should be rejected outright.
                </p>',
                'reference' => '<p>[REF-882]Amit Klein. "Blind XPath Injection". 2004 May 9. < https://dl.packetstormsecurity.net/
                papers/bypass/Blind_XPath_Injection_20040518.pdf >.2023-04-07.</p>
                <p>[REF-62]Mark Dowd, John McDonald and Justin Schuh. "The Art of Software Security
                Assessment". 1st Edition. 2006. Addison Wesley.
                </p>',
            ],
            [
                'name' => "CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')",
                'description' => 'The product uses CRLF (carriage return line feeds) as a special element, e.g. to separate lines or
                records, but it does not neutralize or incorrectly neutralizes CRLF sequences from inputs.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Avoid using CRLF as a special sequence.</p>
                <b>Phase: Implementation</b>
                <p>Appropriately filter or quote CRLF sequences in user-controlled input.</p>',
                'reference' => '<p>[REF-928]Ulf Harnhammar. "CRLF Injection". Bugtraq. 2002 May 7. < http://marc.info/?
                l=bugtraq&m=102088154213630&w=2 >.</p>',
            ],
            [
                'name' => "CWE-94: Improper Control of Generation of Code ('Code Injection')",
                'description' => 'The product constructs all or part of a code segment using externally-influenced input from an
                upstream component, but it does not neutralize or incorrectly neutralizes special elements that
                could modify the syntax or behavior of the intended code segment.',
                'mitigasi' => '<b>Phase: Architecture and Design</b>
                <p>Refactor your program so that you do not have to dynamically generate code.</p>
                <b>Phase: Architecture and Design</b>
                <p>Run your code in a "jail" or similar sandbox environment that enforces strict boundaries between
                the process and the operating system. This may effectively restrict which code can be executed
                by your product. Examples include the Unix chroot jail and AppArmor. In general, managed code
                may provide some protection. This may not be a feasible solution, and it only limits the impact to
                the operating system; the rest of your application may still be subject to compromise. Be careful
                to avoid CWE-243 and other weaknesses related to jails.
                </p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation
                </p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may be
                syntactically valid because it only contains alphanumeric characters, but it is not valid if the input
                is only expected to contain colors such as "red" or "blue." Do not rely exclusively on looking for
                malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if
                the code`s environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which
                inputs are so malformed that they should be rejected outright. To reduce the likelihood of code
                injection, use stringent allowlists that limit which constructs are allowed. If you are dynamically
                constructing code that invokes a function, then verifying that the input is alphanumeric might be
                insufficient. An attacker might still be able to reference a dangerous function that you did not
                intend to allow, such as system(), exec(), or exit().</p>
                <b>Phase: Testing</b>
                <p>Use automated static analysis tools that target this type of weakness. Many modern techniques
                use data flow analysis to minimize the number of false positives. This is not a perfect solution,
                since 100% accuracy and coverage are not feasible.</p>
                <b>Phase: Testing</b>
                <p>Use dynamic tools and techniques that interact with the product using large test suites with
                many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The
                product`s operation may slow down, but it should not become unstable, crash, or generate
                incorrect results.</p>
                <b>Phase: Operation</b>
                <p>Strategy = Compilation or Build Hardening</p>
                <p>Run the code in an environment that performs automatic taint propagation and prevents any
                command execution that uses tainted variables, such as Perl`s "-T" switch. This will force the
                program to perform validation steps that remove the taint, although you must be careful to
                correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted
                (see CWE-183 and CWE-184).
                </p>
                <b>Phase: Operation
                </b>
                <p>Strategy = Environment Hardening</p>
                <p>Run the code in an environment that performs automatic taint propagation and prevents any
                command execution that uses tainted variables, such as Perl`s "-T" switch. This will force the
                program to perform validation steps that remove the taint, although you must be careful to
                correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted
                (see CWE-183 and CWE-184).</p>',
                'refernce' => '<p>[REF-44]Michael Howard, David LeBlanc and John Viega. "24 Deadly Sins of Software Security".
                McGraw-Hill. 2010.</p>',
            ],
            [
                'name' => "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
                ('Eval Injection')",
                'description' => 'The product receives input from an upstream component, but it does not neutralize or incorrectly
                neutralizes code syntax before using the input in a dynamic evaluation call (e.g. "eval").',
                'mitigasi' => '<b>Phase: Architecture and Design</b>
                <b>Phase: Implementation</b>
                <p>If possible, refactor your code so that it does not need to use eval() at all.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may be
                syntactically valid because it only contains alphanumeric characters, but it is not valid if the input
                is only expected to contain colors such as "red" or "blue." Do not rely exclusively on looking for
                malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if
                the code`s environment changes. This can give attackers enough room to bypass the intended
                validation. However, denylists can be useful for detecting potential attacks or determining which
                inputs are so malformed that they should be rejected outright.</p>
                <b>Phase: Implementation</b>
                <p>Inputs should be decoded and canonicalized to the application`s current internal representation
                before being validated (CWE-180, CWE-181). Make sure that your application does not
                inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass
                allowlist schemes by introducing dangerous inputs after they have been checked. Use
                libraries such as the OWASP ESAPI Canonicalization control. Consider performing repeated
                canonicalization until your input does not change any more. This will avoid double-decoding and
                similar scenarios, but it might inadvertently modify inputs that are allowed to contain properlyencoded dangerous content.
                </p>',
                'reference' => '[REF-62]Mark Dowd, John McDonald and Justin Schuh. "The Art of Software Security
                Assessment". 1st Edition. 2006. Addison Wesley.',
            ],
            [
                'name' => "CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static
                Code Injection')",
                'descpription' => 'The product receives input from an upstream component, but it does not neutralize or incorrectly
                neutralizes code syntax before inserting the input into an executable resource, such as a library,
                configuration file, or template.',
                'mitigasi' => '<b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may be
                syntactically valid because it only contains alphanumeric characters, but it is not valid if the input
                is only expected to contain colors such as "red" or "blue." Do not rely exclusively on looking for
                malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if
                the code`s environment changes. This can give attackers enough room to bypass the intended
                validation. However, denylists can be useful for detecting potential attacks or determining which
                inputs are so malformed that they should be rejected outright.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Output Encoding</p>
                <p>Perform proper output validation and escaping to neutralize all code syntax from data written to
                code files.</p>',
                'reference' => '-',
            ],
            [
                'name' => 'CWE-97: Improper Neutralization of Server-Side Includes (SSI) Within a Web
                Page',
                'description' => 'The product generates a web page, but does not neutralize or incorrectly neutralizes usercontrollable input that could be interpreted as a server-side include (SSI) directive.',
                'mitigasi' => '-',
                'reference' => '-',
            ],
            [
                'name' => "CWE-98: Improper Control of Filename for Include/Require Statement in PHP
                Program ('PHP Remote File Inclusion')",
                'description' => 'The PHP application receives input from an upstream component, but it does not restrict or
                incorrectly restricts the input before its usage in "require," "include," or similar functions.',
                'mitigasi' => '<b>Phase: Architecture and Design</b>
                <p>Strategy = Libraries or Frameworks</p>
                <p>Use a vetted library or framework that does not allow this weakness to occur or provides
                constructs that make this weakness easier to avoid.
                </p>
                <b>Phase: Architecture and Design
                </b>
                <p>Strategy = Enforcement by Conversion</p>
                <p>When the set of acceptable objects, such as filenames or URLs, is limited or known, create a
                mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs,
                and reject all other inputs. For example, ID 1 could map to "inbox.txt" and ID 2 could map to
                "profile.txt". Features such as the ESAPI AccessReferenceMap [REF-185] provide this capability.</p>
                <b>Phase: Architecture and Design</b>
                <p>For any security checks that are performed on the client side, ensure that these checks are
                duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side
                checks by modifying values after the checks have been performed, or by changing the client to
                remove the client-side checks entirely. Then, these modified values would be submitted to the
                server.
                </p>
                <b>Phase: Architecture and Design</b>
                <b>Phase: Operation</b>
                <p>Strategy = Sandbox or Jail</p>
                <p>Run the code in a "jail" or similar sandbox environment that enforces strict boundaries between
                the process and the operating system. This may effectively restrict which files can be accessed
                in a particular directory or which commands can be executed by the software. OS-level examples
                include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide
                some protection. For example, java.io.FilePermission in the Java SecurityManager allows the
                software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to
                compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.</p>
                <p>Effectiveness = Limited</p>
                <p>The effectiveness of this mitigation depends on the prevention capabilities of the specific
                sandbox or jail being used and might only help to reduce the scope of an attack, such as
                restricting the attacker to certain system calls or limiting the portion of the file system that can be
                accessed.</p>
                <b>Phase: Architecture and Design</b>
                <b>Phase: Operation</b>
                <p>Strategy = Environment Hardening</p>
                <p>Run your code using the lowest privileges that are required to accomplish the necessary tasks
                [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a
                single task. That way, a successful attack will not immediately give the attacker access to the
                rest of the software or its environment. For example, database applications rarely need to run as
                the database administrator, especially in day-to-day operations.</p>
                <b>Phase: Implementation</b>
                <p>Strategy = Input Validation</p>
                <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                strictly conform to specifications, or transform it into something that does. When performing
                input validation, consider all potentially relevant properties, including length, type of input, the
                full range of acceptable values, missing or extra inputs, syntax, consistency across related
                fields, and conformance to business rules. As an example of business rule logic, "boat" may be
                syntactically valid because it only contains alphanumeric characters, but it is not valid if the input
                is only expected to contain colors such as "red" or "blue." Do not rely exclusively on looking for
                malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if
                the code`s environment changes. This can give attackers enough room to bypass the intended
                validation. However, denylists can be useful for detecting potential attacks or determining which
                inputs are so malformed that they should be rejected outright. When validating filenames, use
                stringent lists that limit the character set to be used. If feasible, only allow a single "." character
                in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such
                as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434.
                Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters.
                This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering "/"
                is insufficient protection if the filesystem also supports the use of "\" as a directory separator.
                Another possible error could occur when the filtering is applied in a way that still produces
                dangerous data (CWE-182). For example, if "../" sequences are removed from the ".../...//" string
                in a sequential fashion, two instances of "../" would be removed from the original string, but the
                remaining characters would still form the "../" string.</p>
                <p>Effectiveness = High</p>
                <b>Phase: Architecture and Design</b>
                <b>Phase: Operation</b>
                <p>Strategy = Attack Surface Reduction</p>
                <p>Store library, include, and utility files outside of the web document root, if possible. Otherwise,
                store them in a separate directory and use the web server`s access control capabilities to prevent
                attackers from directly requesting them. One common practice is to define a fixed constant in
                each calling program, then check for the existence of the constant in the library/include file; if the
                constant does not exist, then the file was directly requested, and it can exit immediately. This significantly reduces the chance of an attacker being able to bypass any protection mechanisms
                that are in the base program but not in the include files. It will also reduce the attack surface.
                </p>
                <b>Phase: Architecture and Design</b>
                <b>Phase: Implementation</b>
                <p>Strategy = Attack Surface Reduction
                </p>
                <p>Understand all the potential areas where untrusted inputs can enter your software: parameters
                or arguments, cookies, anything read from the network, environment variables, reverse DNS
                lookups, query results, request headers, URL components, e-mail, files, filenames, databases,
                and any external systems that provide data to the application. Remember that such inputs
                may be obtained indirectly through API calls. Many file inclusion problems occur because the
                programmer assumed that certain inputs could not be modified, especially for cookies and URL
                components.</p>
                <b>Phase: Operation</b>
                <p>Strategy = Firewal</p>
                <p>Use an application firewall that can detect attacks against this weakness. It can be beneficial
                in cases in which the code cannot be fixed (because it is controlled by a third party), as an
                emergency prevention measure while more comprehensive software assurance measures are
                applied, or to provide defense in depth.</p>
                <p>Effectiveness = Moderate
                </p>
                <p>An application firewall might not cover all possible input vectors. In addition, attack techniques
                might be available to bypass the protection mechanism, such as using malformed inputs that can
                still be processed by the component that receives those inputs. Depending on functionality, an
                application firewall might inadvertently reject or modify legitimate requests. Finally, some manual
                effort may be required for customization.</p>
                <b>Phase: Operation</b>
                <b>Phase: Implementation</b>
                <p>Strategy = Environment Hardening</p>
                <p>Develop and run your code in the most recent versions of PHP available, preferably PHP 6 or
                later. Many of the highly risky features in earlier PHP interpreters have been removed, restricted,
                or disabled by default.</p>
                <b>Phase: Operation</b>
                <b>Phase: Implementation</b>
                <p>Strategy = Environment Hardening</p>
                <p>When using PHP, configure the application so that it does not use register_globals. During
                implementation, develop the application so that it does not rely on this feature, but be wary of
                implementing a register_globals emulation that is subject to weaknesses such as CWE-95,
                CWE-621, and similar issues. Often, programmers do not protect direct access to files intended
                only to be included by core programs. These include files may assume that critical variables have
                already been initialized by the calling program. As a result, the use of register_globals combined
                with the ability to directly access the include file may allow attackers to conduct file inclusion
                attacks. This remains an extremely common pattern as of 2009.</p>
                <b>Phase: Operation</b>
                <p>Strategy = Environment Hardening</p>
                <p>Set allow_url_fopen to false, which limits the ability to include files from remote locations.</p>
                <p>Effectiveness = High</p>
                <p>Be aware that some versions of PHP will still accept ftp:// and other URI schemes. In addition,
                this setting does not protect the code from path traversal attacks (CWE-22), which are frequently
                successful against the same vulnerable code that allows remote file inclusion.
                </p>',
                'reference' => '<p>[REF-185]OWASP. "Testing for Path Traversal (OWASP-AZ-001)". < http://www.owasp.org/index.php/Testing_for_Path_Traversal_(OWASP-AZ-001) >.</p>
                <p>[REF-76]Sean Barnum and Michael Gegick. "Least Privilege". 2005 September 4. < https://
                web.archive.org/web/20211209014121/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/least-privilege >.2023-04-07.</p>
                <p>[REF-951]Shaun Clowes. "A Study in Scarlet". < https://www.cgisecurity.com/lib/studyinscarlet.txt>.2023-04-07.</p>
                <p>[REF-952]Stefan Esser. "Suhosin". < http://www.hardened-php.net/suhosin/ >.</p>
                <p>[REF-953]Johannes Ullrich. "Top 25 Series - Rank 13 - PHP File Inclusion". 2010 March 1. SANS
                Software Security Institute. < https://www.sans.org/blog/top-25-series-rank-13-php-file-inclusion/
                >.2023-04-07.</p>',
                ],
                [
                    'name' => "CWE-99: Improper Control of Resource Identifiers ('Resource Injection')",
                    'description' => 'The product receives input from an upstream component, but it does not restrict or incorrectly
                    restricts the input before it is used as an identifier for a resource that may be outside the intended
                    sphere of control.',
                    'mitigasi' => '<b>Phase: Implementation</b>
                    <p>Strategy = Input Validation</p>
                    <p>Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use
                    a list of acceptable inputs that strictly conform to specifications. Reject any input that does not
                    strictly conform to specifications, or transform it into something that does. When performing
                    input validation, consider all potentially relevant properties, including length, type of input, the
                    full range of acceptable values, missing or extra inputs, syntax, consistency across related
                    fields, and conformance to business rules. As an example of business rule logic, "boat" may be
                    syntactically valid because it only contains alphanumeric characters, but it is not valid if the input
                    is only expected to contain colors such as "red" or "blue." Do not rely exclusively on looking for
                    malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if
                    the code`s environment changes. This can give attackers enough room to bypass the intended
                    validation. However, it can be useful for detecting potential attacks or determining which inputs
                    are so malformed that they should be rejected outright.
                    </p>',
                    'reference' => '<p>[REF-6]Katrina Tsipenyuk, Brian Chess and Gary McGraw. "Seven Pernicious Kingdoms: A
                    Taxonomy of Software Security Errors". NIST Workshop on Software Security Assurance Tools
                    Techniques and Metrics. 2005 November 7. NIST. < https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf >.
                    </p>
                    <p>[REF-962]Object Management Group (OMG). "Automated Source Code Security Measure
                    (ASCSM)". 2016 January. < http://www.omg.org/spec/ASCSM/1.0/ >.
                    </p>',
                ],
        ];

        DB::table('mastervulnerabilities')->insert($data);
    }
}
